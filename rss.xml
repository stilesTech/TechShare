<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[stiles 的技术分享]]></title>
        <description><![CDATA[🌟 分享效率方法 🪄、优质文章 📑、编程知识 🎹、实用工具 🛠️ 和有趣内容 😄。]]></description>
        <link>http://stiles.cc</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Fri, 03 Feb 2023 06:19:35 GMT</lastBuildDate>
        <atom:link href="http://stiles.cc/rss.xml" rel="self" type="application/rss+xml"/>
        <copyright><![CDATA[stiles 2023]]></copyright>
        <language><![CDATA[zh-CN]]></language>
        <item>
            <title><![CDATA[代码精进之路]]></title>
            <link>http://stiles.cc/docs/coding/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/coding/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF.html</guid>
            <pubDate>Mon, 19 Dec 2022 10:50:08 GMT</pubDate>
            <content:encoded><![CDATA[ <p>自述: 整洁代码是十分有必要的,在平时的编程工作中,基本上更多的时间是花在阅读别人的代码上面,写出优雅整洁的代码这正是我们所需要的.</p> <p><strong>一切的原则：容易理解的代码</strong></p> <p>1：Bjarne Stroustrup ,C++发明者:我喜欢优雅和高效的代码。代码逻辑应当直截了当，叫缺陷难以隐藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码；性能调至最优，省得引诱别人做没规矩的优化，搞出一堆混乱来。整洁的代码只做好一件事。</p> <p>2：Ron c#（c#极限编程探索）作者简单的代码，依其重要顺序：能通过所有测试；没有重复的代码；体现系统中的全部设计理念；包含尽量少的实体，比如类，方法，函数等。</p> <p>以下大多数资料来源于书籍<strong>代码整洁之道</strong>,<a href="https://book.douban.com/subject/4199741/" target="_blank" rel="noopener noreferrer">链接<span> </span></a></p> <p><strong>1.关于命名</strong>1：有意义的命名，避免前缀,添加有意义的语境2：如果你无法想出一个合适的名字，很可能意味着代码“坏味道”（功能太多，内聚性不够，理解不够透彻）3：变量是名词（正确描述业务），方法是动词（有表现力不空泛）类名应该是名词或名词短语</p> <div class="language- extra-class"><pre class="language-text"><code>int d；//消逝的时间，以日计
private void processData(){}
public class Customer{}
</code></pre></div><p>4:有意义的区分</p> <div class="language- extra-class"><pre class="language-text"><code>getActiveAccount()；
getActiveAccounts()；
getActiveAccountInfo()；
</code></pre></div><p>5:使用读的出来的命名缩写有时候没有意义，看得懂的命名比模糊的命名更有表现力,长而具有描述性的名称，要比短而令人费解的名称好</p> <p>5.1:代码的写法应该使理解代码的人所需要的时间最小化。</p> <p>5.2:时间:9读1写</p> <p>5.3:一般来说代码是越少越好,但不都是这样有时候,一行代码不容易理解可是适当拆分增加可读性把信息装到名字里</p> <p><strong>给名字附加额外信息</strong></p> <table><thead><tr><th>场景</th> <th>变量名</th> <th>更好的名字</th></tr></thead> <tbody><tr><td>一个纯文本的密码，需要加密后才可以使用</td> <td>password</td> <td>plaintextPassword</td></tr> <tr><td>一条用户评论，需要转义后显示</td> <td>comment</td> <td>unescapedComment</td></tr> <tr><td>已转化为UTF-8的HTML文本</td> <td>html</td> <td>htmlUtf8</td></tr> <tr><td>以"URL"方式编码的输入数据</td> <td>data</td> <td>dataURLEncode</td></tr></tbody></table> <p><strong>带单位的命名</strong></p> <table><thead><tr><th>参数或变量</th> <th>带单位的命名</th></tr></thead> <tbody><tr><td>start(int delay)</td> <td>delay -&gt; delaySecs</td></tr> <tr><td>createCache(int size)</td> <td>size -&gt; sizeMB</td></tr> <tr><td>throttleDownload(float limit)</td> <td>limit -&gt; maxKB</td></tr> <tr><td>setHeight(float height)</td> <td>height -&gt; heightCM</td></tr></tbody></table> <p><strong>有表现力的词</strong></p> <table><thead><tr><th>单词</th> <th>更多选择</th></tr></thead> <tbody><tr><td>send</td> <td>deliver、dispatch、announce、distribute、route</td></tr> <tr><td>find</td> <td>search、extract、locate、recover</td></tr> <tr><td>start</td> <td>launch、create、begin、open</td></tr> <tr><td>make</td> <td>create、set up、build、generate、compose、add、new</td></tr></tbody></table> <p>1.使用专业的词</p> <p>2.避免使用空泛的词</p> <p>3.给变量名带上附加信息</p> <p>4.为作用域更大的变量起一个长的名字</p> <p>5.有目的的使用大小写和下划线</p> <p>6.有表现力的词*清晰的命名和精确的命名比看起来容易懂的命名要更有表现力</p> <p><a href="https://github.com/google/styleguide" target="_blank" rel="noopener noreferrer">谷歌代码规范<span> </span></a> | <a href="http://zh-google-styleguide.readthedocs.io/en/latest/" target="_blank" rel="noopener noreferrer">中文<span> </span></a><a href="https://google.github.io/styleguide/javaguide.html" target="_blank" rel="noopener noreferrer">Java 代码规范<span> </span></a><a href="https://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener noreferrer">C++ 代码规范<span> </span></a><a href="https://github.com/google/styleguide/blob/gh-pages/pyguide.md" target="_blank" rel="noopener noreferrer">Python 代码规范<span> </span></a><a href="https://google.github.io/styleguide/jsguide.html" target="_blank" rel="noopener noreferrer">JavaScript 代码规范<span> </span></a></p> <p><strong>2.关于函数</strong></p> <p>1：应该尽量短小，方法不要超过20行代码</p> <p>2：只做一件事情（做好这件事，只做这一件事）</p> <p>3：一个函数中的抽象在同一个水平上，而不是高层抽象和实现细节混杂在一起。SLAP（Single Level of Abstration Principle）</p> <p>4：函数参数尽量少，参数尽量别反直觉。多余3个可以考虑封装为类</p> <p>5：减少辅助代码（比如：日志，鉴权，缓存检测 Aop面向切面编程）</p> <p>6：自顶向下读代码：向下规则（每个函数后面都跟着位于下一抽象层次的函数）</p> <p>7：函数应该只做一件事，错误处理就是一件事，处理错误的函数应该不做其它事，如果try在某个函数存在，他应该是第一个单词。而且catch/finally不应该包含其它内容</p> <p>8：别返回null值</p> <p>9：不建议使用Map在系统中传递</p> <p><strong>3.关于注释</strong></p> <p>1：注释不能美化代码，有时候注释会撒谎</p> <p>2：对意图的解释（某个决定后面的意图）</p> <p>3：不能修改的标准库之类的参数和返回值进行解释</p> <p>4：警示，提醒程序的某种后果</p> <p>5：TODO注释（解释为什么该函数的实现部分无所作为，将来应该是怎样）4：用代码来阐述</p> <p><strong>4.对象和数据结构</strong></p> <p>1：对象：对象把数据隐藏于抽象之后，曝露操作数据的函数</p> <p>2：数据结构：数据结构曝露其数据，没有提供有意义的函数。最为精练的数据结构：是一个只有公共变量，没有函数的类。（DTO-Data Transfer Objects）</p> <p><strong>5.关于类</strong></p> <p>1：类应该短小</p> <p>2：单一权责:类和模块应该只有一条加以修改的理由</p> <p><strong>6.设计原则</strong></p> <p>Kent Beck 简单设计的四条原则</p> <p>1：运行所有测试；</p> <p>2：不可重复</p> <p>3：表达了程序员的意图</p> <p>4：尽可能减少类和方法的数量*以上规则按其重要程度排序尽量使类和函数的数量尽量少是很重要，但更重要的却是测试，消除重复和表达力</p> <p>Single Responsibility Principle（SRP）：单一职责原则。Open Close Principle（OCP）：开闭原则。Liskov Substitution Principle（LSP）：里氏替换原则。Interface Segregation Principle（ISP）：接口隔离原则。Dependency Inversion Principle（DIP）：依赖倒置原则。</p> <p>SRP（单一职责原则）任何一个软件模块中，应该有且只有一个被修改的原因。职责越单一，被修改的原因就越少，模块的内聚性（Cohesion）就越高,被复用的可能性就越大，也更容易被理解。软件实体应该对扩展开放，对修改关闭。</p> <p>OCP（开闭原则）软件实体应该对扩展开放，对修改关闭。</p> <p>LSP（里氏替换原则）程序中的父类型都应该可以正确地被子类型替换。程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”，即子类应该可以替换任何基类能够出现的地方，并且经过替换后，代码还能正常工作.</p> <p>ISP（接口隔离原则）</p> <p>多个特定客户端接口要好于一个宽泛用途的接口。</p> <p>接口隔离原则认为不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口要好。</p> <p><img src="http://stiles.cc/assets/img/4227884396.72b5f6fa.png" alt="../uploads/2020/12/4227884396.png"></p> <p>未遵循ISP的示例</p> <p><img src="http://stiles.cc/assets/img/2757206913.39caae8a.png" alt="../uploads/2020/12/2757206913.png"></p> <p>遵循ISP的示例</p> <p>DIP（依赖倒置原则）</p> <p>模块之间交互应该依赖抽象，而非实现。</p> <p>1:面向接口编程</p> <p>2:DIP本身的意义要宽泛得多，它是一种思想，是一种软件设计的哲学。</p> <p>DRY(不要重复)DRY是Don’t Repeat Yourself的缩写，DRY原则特指在程序设计和计算中避免重复代码1:因为这样会降低代码的灵活性和简洁性2:可能导致代码之间的矛盾</p> <p>YAGNIYAGNI（You Ain’t Gonna Need It）的意思是“你不会需要它”1:YAGNI是针对“大设计”（Big Design）提出来的，是“极限编程”提倡的原则，2:不要过度设计，它背后的指导思想就是尽可能快、尽可能简单地让软件运行起来。</p> <p>Rule of ThreeRule of Three也被称为“三次原则”，三次原则指导我们可以通过以下步骤来写代码。（1）第一次用到某个功能时，写一个特定的解决方法。（2）第二次又用到的时候，复制上一次的代码。（3）第三次出现的时候，才着手“抽象化”，写出通用的解决方法。1：是对DRY原则和YAGNI原则的折中2：反对过度设计（OverDesign），也绝对不赞成无设计（No Design）</p> <p>KISS原则事情变复杂很简单，把事情变简单很复杂。好的目标不是越复杂越好，反而是越简洁越好。</p> <p>POLA原则（最小惊奇原则）POLA（Principle of least astonishment）是最小惊奇原则要的是简单易懂，而不是时不时冒出个“Surprise”。</p> <p>你可以，不代表你应该。（Just because you can, doesn’t mean you should.）——施莉琳·凯尼恩</p> <p><strong>7.味道与启发</strong></p> <p>注释：</p> <p>1：不恰当的信息</p> <p>2：废弃的注释</p> <p>3：冗余的注释</p> <p>4：糟糕的注释</p> <p>5：注释掉的代码</p> <p>环境：</p> <p>1：需要多久才能实现的构建</p> <p>2：需要多久才能做到的测试</p> <p>函数</p> <p>1：过多的参数</p> <p>2：输出参数违反直觉</p> <p>3：标识参数（布尔值参数）</p> <p>4：死函数（永不被调用的方法）</p> <p>一般性问题</p> <p>1：一个源文件中存在多种语言</p> <p>2：明显的行为未被实现（最小惊奇原则）</p> <p>3：不正确的边界行为（别依赖直觉，追索每种边界的条件，并编写测试）</p> <p>4：忽视安全（遵守安全就不便于做试验，结果就是试验未能运行，忽视安全相当危险）</p> <p>5：重复（重复代码代表遗漏了抽象）</p> <p>6：在错误的抽象层级上的代码（低层级的概念（细节有关的常量，变量或工具函数）放在派生类中，所有较高层级概念放在基类中）</p> <p>7：基类依赖于派生类</p> <p>8：信息过多</p> <p>9：死代码</p> <p>10：垂直分隔变量和函数应该在靠近被使用的地方定义。本地函数应该正好在首次使用的位置上声明，垂直距离要短私有函数应该刚好在其首次被使用的位置下面定义。找个私有函数，应该只是从其首次被使用处往下看一点那么简单</p> <p>11：前后不一致（最小惊奇原则，小心选择约定一旦选中，就小心持续遵循）</p> <p>12：混淆视听（不使用的构造函数，变量，函数，没有信息量的注释都应该去掉）</p> <p>13：人为耦合</p> <p>14：特性依恋（类的方法只应对其所属类中的变量和函数感兴趣，不该垂青其它类中的变量和函数）</p> <p>15：选择算子参数（boolean参数）</p> <p>16：晦涩的意图</p> <p>17：位置错误的权责</p> <p>18：不恰当的静态方法</p> <p>19：使用解释性变量</p> <p>20：函数名称应该表达其行为</p> <p>21：理解算法</p> <p>22：把逻辑依赖改成物理依赖</p> <p>23：用多态代替if/else或switch/case</p> <p>24：遵循标准约定</p> <p>25：用命名常量替代魔术数</p> <p>...</p> <p>参考资料:书籍:(代码整洁之道)：<a href="https://book.douban.com/subject/4199741/https://github.com/biezhi/write-readable-code" target="_blank" rel="noopener noreferrer">链接<span> </span></a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用n8n订阅网站rss消息推送到Telegram]]></title>
            <link>http://stiles.cc/docs/tools/%E4%BD%BF%E7%94%A8n8n%E8%AE%A2%E9%98%85%E7%BD%91%E7%AB%99rss%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%88%B0Telegram.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/tools/%E4%BD%BF%E7%94%A8n8n%E8%AE%A2%E9%98%85%E7%BD%91%E7%AB%99rss%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%88%B0Telegram.html</guid>
            <pubDate>Thu, 28 Jul 2022 11:42:06 GMT</pubDate>
            <content:encoded><![CDATA[ <p>n8n 是一个免费且开放的、公平代码许可的基于节点的工作流自动化工具。它可以自托管、易于扩展。可帮助您将任何具有 API 的应用程序与任何其他应用程序连接起来，并使用很少或无需代码来操作其数据。</p> <blockquote><p>n8n is a free and open <a href="https://link.juejin.cn/?target=http%3A%2F%2Ffaircode.io%2F" target="_blank" rel="noopener noreferrer">fair-code<span> </span></a> licensed node based Workflow Automation Tool. It can be self-hosted, easily extended. helps you to connect any app with an API with any other, and manipulate its data with little or no code.</p></blockquote> <h1 id="关于n8n">关于n8n</h1> <p>简单点来讲，n8n就是一个能够链接多个API应用程序，基于自定义工作流进行协作的开源工具。
接下来演示下如何通过n8n实现网站rss更新通知到telegram.</p> <p>1:创建telegram机器人</p> <p>2:获取chat id</p> <p>3:构建n8n事件流</p> <p><strong>1.如何为Telegram创建机器人</strong></p> <p>首先是第一件事。您需要注册Telegram。</p> <p>打开Telegram应用程序，搜索@BotFather并开始聊天。发送/newbot命令并按照说明进行操作。完成初始步骤后，您将获得：</p> <ul><li>您自己的令牌</li> <li>Telegram api URL - api.telegram.org/</li> <li>链接到文档</li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f59ca61b6f0d40e1ba0ed04e609ddab5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-07-29_14-11-33.png"></p> <p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fapi.telegram.org%2Fbot5471903376%3AAAF7XmoadmlkFiLKgRA1SnQKcP23MkrKN7I%2FgetUpdates" target="_blank" rel="noopener noreferrer">api.telegram.org/bot54719033…<span> </span></a></p> <p><strong>2.获取 chatId</strong></p> <p>观察这个 url <code>https://api.telegram.org/bot{token}/getUpdates</code></p> <p>使用第一步获得的 <code>token</code> 替换上述 url 中的 <code>{token}</code> 然后得到新的 url，复制粘贴到浏览器地址栏，回车请求。不出意外你会得到如下 response</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
    <span class="token property">"ok"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token property">"result"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
复制代码
</code></pre></div><p>回到telegram进入到你创建的机器人会话，随便和它说一句话，比如给它发一句 "Hello World"，然后重新请求一遍上述的 url <code>https://api.telegram.org/bot{token}/getUpdates</code>，不出意外你收到的 response 类似是这样了</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">"ok"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token property">"result"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
        ...
        <span class="token property">"chat"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">5210226195</span><span class="token punctuation">,</span>
          <span class="token property">"first_name"</span><span class="token operator">:</span> <span class="token string">"摩根"</span><span class="token punctuation">,</span>
          <span class="token property">"last_name"</span><span class="token operator">:</span> <span class="token string">"侦探"</span><span class="token punctuation">,</span>
          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"private"</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
复制代码
</code></pre></div><p>其中的 result[0].message.chat.id 的值就是 <code>chatId</code> 也就是 5210226195
知道了 token 和 chatId 就可以使用 bot 了。</p> <h1 id="curl-测试">curl 测试</h1> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">curl</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-X</span> POST https://api.telegram.org/bot<span class="token punctuation">{</span>token<span class="token punctuation">}</span>/sendMessage <span class="token parameter variable">-d</span> <span class="token assign-left variable">chat_id</span><span class="token operator">=</span><span class="token punctuation">{</span>chatId<span class="token punctuation">}</span> <span class="token parameter variable">-d</span> <span class="token assign-left variable">text</span><span class="token operator">=</span><span class="token string">"Hello World"</span>
复制代码
</code></pre></div><p>这是发送 post 请求。使用实际的 <code>token</code> 和 <code>chatId</code> 替换 shell command 中的 <code>{token}</code> 和 <code>{chatId}</code>
不出意外，你的 bot 会收到 "Hello World"，恭喜，这已经成功了！</p> <p><strong>3.搭建n8n流水线</strong></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a29f493f9ef41bcb716aa3087ee27c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-07-29_11-36-56.png"></p> <p>我是参考: <strong><a href="https://link.juejin.cn/?target=https%3A%2F%2Fforum.cloudron.io%2Ftopic%2F5736%2Fsetting-up-an-automated-blog-using-n8n-tiny-tiny-rss" target="_blank" rel="noopener noreferrer">Setting up an Automated Blog using n8n &amp; Tiny Tiny RSS<span> </span></a></strong></p> <p>1：选择一个支持rss的网站，比如：(<a href="https://link.juejin.cn/?target=http%3A%2F%2Fstiles.cc%2Ffeed%2F" target="_blank" rel="noopener noreferrer">stiles.cc/feed/<span> </span></a>)</p> <p>2：使用<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.notion.so%2F7b02a7745abf4350ba2e5839800fe039" target="_blank" rel="noopener noreferrer">rss-stiles-workflow<span> </span></a>地址，导入对应的工作流</p> <p>3：替换RSS Feed Read模块成想要订阅的RSS地址</p> <p>4：替换Telegram模块成之前获取到的token和chatid</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eabfd220952d47fd93ce7edca2125e72~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-07-29_13-59-03.png"></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66885be7c504413a8cf268c51c9ca028~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-07-29_14-01-23.png"></p> <p>执行该workflow，但rss站点有新的文章发布的时候，telegram就能相应的发送消息通知，如下图：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61b8d3e869db449586de213447029898~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-07-29_14-45-02.png"></p> <p>实际上n8n可以实现很多场景，你可以通过<a href="https://link.juejin.cn/?target=https%3A%2F%2Fn8n.io%2Fworkflows%2F" target="_blank" rel="noopener noreferrer">n8n.io/workflows<span> </span></a> 去搜索需要的工作流。比较容易想到的，devops流水线，多端消息互通，自动通信telegram机器人等</p> <p>参考资料</p> <p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fhellodk.cn%2Fpost%2F743" target="_blank" rel="noopener noreferrer">hellodk.cn/post/743<span> </span></a></p> <p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fforum.cloudron.io%2Ftopic%2F5736%2Fsetting-up-an-automated-blog-using-n8n-tiny-tiny-rss" target="_blank" rel="noopener noreferrer">forum.cloudron.io/topic/5736/…<span> </span></a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Upsource实践指南]]></title>
            <link>http://stiles.cc/docs/engineering/Upsource%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/engineering/Upsource%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97.html</guid>
            <pubDate>Tue, 10 May 2022 12:36:01 GMT</pubDate>
            <content:encoded><![CDATA[ <h2 id="简介">简介</h2> <p>Upsource是一款由Jetbrains公司出品的代码审查工具，具有社交属性，将代码予以团队成员或其他人分享，讨论。浏览代码视觉效果美观，可以与IDEA无缝集成，完成代码审查工作。</p> <p>官方文档：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.jetbrains.com%2Fhelp%2Fupsource%2Fgetting-started.html" target="_blank" rel="noopener noreferrer">点击查看<span> </span></a></p> <h2 id="一-代码审查中的角色">一：代码审查中的角色</h2> <p>在 Upsource 中，典型的代码审查过程涉及两个或多个参与者，可分为以下角色：</p> <ul><li><strong>Author</strong> 是一个提交者，代码审查即是来检查他/她所提交的更改。</li> <li><strong>Reviewer</strong> 应检查作者提交的更改并留下反馈。他还可以完成审查、提出对更改的关注,也可以关闭这次审查。</li> <li><strong>Watcher</strong> 预计不会参与审核过程。不太需要去关心代码的细节修改，关注重点是项目的状态以及团队成员的讨论。</li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f2a0b9027cf4163b7ced60bbed5a3cd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-05-10_11-33-47.png">
如何邀请别人审查代码，作为Review的发起者，你可以点击左侧Overview 模块下对应的+符号， 邀请团队成员或者其他人作为<code>reviewer</code>或者<code>watcher</code>，同时，你可以将<code>鼠标悬停在头像之上</code>，看到该成员本次review的进度,如下所示</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9c577f6db284a34b777f2637115d633~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-05-10_11-36-08.png"></p> <h2 id="二-审查流程"><strong>二：审查流程</strong></h2> <p>代码的修改者一般作为审查流程的发起者，如果要邀请团队成员其他成员进行代码审查，需要进行以下操作：</p> <ul><li>将更改内容提交到版本管理系统（Gitlab/Github）。</li> <li>创建一个审查流程（可以设置为系统自动发起）。</li> <li>邀请审查参与者（Reviewer和可选的Watcher）。</li> <li>讨论代码的问题，审查流程参与者交换意见。</li> <li>Author解决问题，提交版本修订，并将新的修订添加到现有的评审中。（IDEA的Upsource插件支持自动添加）</li> <li>当Reviewer接受你的修改后，便可以关闭审查流程。</li></ul> <p>以下详细讲解如何创建Upsource代码审查。</p> <h2 id="三-案例演示">三：案例演示</h2> <h3 id="发起评论">发起评论</h3> <p>创建了2个developer角色的账号，developer1和developer2.</p> <p>使用developer1账号进行评论，点击红色的铅笔icon进行评论，在评论框中可以使用@符号来通知到对应的开发人员。</p> <p>如下所示发送了：@developer2 是否有添加单元测试？</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6c175b895c24335b1349537b7e5bdb8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-05-10_11-44-20.png"></p> <p>切换到developer2账号，点击review视图，可以查看到对应的的评论信息，如下图</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bc942e10337487c95fa862dd0d8fc30~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-05-07_18-14-22.png"></p> <p>点击#符号可以跳转到具体评论位置，进行回复</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f05c64cf8e6f4d60bbe75427f2d2e618~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-05-07_18-07-50.png"></p> <p>developer1评论发起者可以通过点击右侧的resolve按钮表示处理已解决，</p> <p>也可以点击添加对应标签，标注这个问题是功能性的BUG还是代码的样式问题等。也可以自定义标签在全局项目中使用。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05bf5aa2078041b583f102136bd81e8b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-05-10_11-50-45.png"></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a7e555b36f44ffdbfddee60dd4bd232~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-05-07_18-21-09.png"></p> <h3 id="取消消息推送">取消消息推送</h3> <p>如果想停止对评论的监视，停止接收消息通知，可以从观察者列表中删除你自己。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44662a477f9941e2b3a4969e2e54e512~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-05-10_11-53-52.png"></p> <p>如果不想删除自己，可以设置为Mute review（消息免打扰），这样这个评审后续的讨论信息就不会出现在你的News Feed中了。不过链接到评审中还是可以看到的。</p> <h3 id="通过审查">通过审查</h3> <p>如果你对作者的修改感到满意，那你就可以点击Accept。如果你觉得这些问题值得怀疑，那就点击<code>Raise concern</code></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c7f524127b643c2848b10ec43ac9744~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-05-10_11-55-50.png"></p> <p>如果最初提交的修订没有得到Reviewer的Accept，可以按照Reviewer的要求处理这些问题并提交代码的修订到gitlab，然后可以将一个或几个新的修订附加到原始审核中以获得Accept。</p> <h3 id="发起修订">发起修订</h3> <p>使用idea提交代码的时候可以勾选Amend(修订)，勾选review with upsource选择对应的审查记录。完成一次修订提交。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75c953e9527f43bf846c31dbe9f1c4d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-05-09_16-56-28.png"></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96f03c89c20f46bbb8991b7d0b42c0d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-05-09_17-04-42.png"></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b4d08a6b3b64bfa960e391676269071~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-05-10_11-58-01.png"></p> <h3 id="完成审查">完成审查</h3> <p>当达到所有审查者的要求后，审查者都Accept/raise concern这个 Review的修改结果后，表示接受此次修订，此次审查被视为完成。</p> <h3 id="关闭审查">关闭审查</h3> <p>审查者和代码作者都可以关闭 Review，可以在项目属性设置中代码作者是否有关闭Review的权限。</p> <h3 id="审核状态">审核状态</h3> <p>审查可以经历三个不同的阶段：</p> <ol><li><strong>待定</strong>— 已创建审阅并分配审阅者。</li> <li><strong>已完成</strong>——所有审阅者通过接受（accept ）或关注（raise concern）变更的时候。</li> <li><strong>已关闭</strong>— 由作者关闭，因为不需要或期望所有参与者采取进一步行动。</li></ol> <h2 id="四-其它实践">四：其它实践</h2> <p>upource允许自动添加工作流程，例如：可以通过添加对应触发器，自动添加对应的代码审查者</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cac8ccc251fc431c8d9bcf2eaac20b36~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-05-10_17-11-09.png"></p> <p>也可以通过webhook完成整个自动构建流程和消息通知等</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09f322c20fb049b3a6e022f956d6f8e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Snipaste_2022-05-10_17-11-43.png"></p> <p>比如通过upsource webhook 发送对应通知消息，或者触发对应jenkins任务。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[代码审查指南]]></title>
            <link>http://stiles.cc/docs/coding/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E6%8C%87%E5%8D%97.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/coding/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E6%8C%87%E5%8D%97.html</guid>
            <pubDate>Sun, 08 May 2022 22:50:08 GMT</pubDate>
            <content:encoded><![CDATA[ <p>代码审查的主要目的是确保代码库的整体代码健康状况随着时间的推移而改善。代码审查的所有工具和过程都是为此目的而设计的。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a75be9014c2b4105952b8d44ad047db0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="codereview_friendly.png"></p> <h2 id="why-为什么要代码审查">（why）为什么要代码审查</h2> <blockquote><p><em>Peer review—an activity in which people other than the author of a software deliverable examine it for defects and improvement opportunities—is one of the most powerful software quality tools available. Peer review methods include inspections, walkthroughs, peer desk checks, and other similar activities.</em></p> <p><em>- Karl E. Wiegers</em></p></blockquote> <p>上面这句话大概意思是: 同行评审软件交付物作者以外的其他人在其中检查缺陷和改进机会的活动,是可用的最强大的软件质量工具之一。同行评审方法包括检查、排查、同行桌面检查和其他类似活动。</p> <p>1.<strong>尽早发现 Bug 和设计中存在的问题,统一编码风格.</strong></p> <p>2.知识共享，获得最佳实践（如果在您的代码被审查时某个人建议一种更好的方法去做一些事）</p> <p>3.提高代码质量（当人们知道有人在阅读信息时，他们往往会写的更好）</p> <p>4.了解项目状态，至少有另一个人熟悉你的代码</p> <h2 id="who-谁做代码审查">（who）谁做代码审查</h2> <p>项目经理/架构师/相关开发人员/比你更资深的程序员，希望得到他们的专业反馈</p> <h2 id="how-如何进行代码审查">（how）如何进行代码审查</h2> <h2 id="_1-规范标准">1 规范标准</h2> <ol><li>原子性提交。一个提交包含一个不可分割的特性、修复或者优化，同时这个提交要尽可能小。(提交尽可能小可以聚焦，让错误/问题 一目了然)</li> <li>使用统一的代码风格 （阿里巴巴JAVA开发规范）</li> <li>当遇到代码冲突出现共识冲突的情况，通过视频/面对面询问的方式，而非通过代码审查评论来解决冲突。</li></ol> <h2 id="_2-审查的时机">2 审查的时机</h2> <p>最好的审查时机是，功能分支自测完成后，需要合并到 develop 分支申请提测前。越往后修改成本越高。</p> <p>提交 ：原则上至少一天提交一次。</p> <p>审查：代码审查理论上可以在任何碎片化时间进行，推荐在每天早上或者下班前抽出一段固定的时间审查前天/当天提交的代码。</p> <p>时间：单次代码审查的时间保持在5-20分钟</p> <h2 id="_3-代码评审应该关注的重点">3 代码评审应该关注的重点</h2> <ul><li>代码设计是否合理，是否有违背基本的设计模式理念（SOLID）</li> <li>代码的行为是否符合作者的预期，是否明显的逻辑错误</li> <li>是否符合系统的代码规范</li> <li>代码的可读性和可维护性是否良好，是否可以更简单。</li> <li>类，变量，方法等命名是否清晰</li></ul> <p><strong>参考资料</strong></p> <p>Google 工程实践文档:<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Feng-practices" target="_blank" rel="noopener noreferrer">github.com/google/eng-…<span> </span></a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[wx-hub微信公众号文章同步工具]]></title>
            <link>http://stiles.cc/docs/tools/wx-hub%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/tools/wx-hub%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7.html</guid>
            <pubDate>Tue, 26 Apr 2022 05:22:06 GMT</pubDate>
            <content:encoded><![CDATA[ <h2 id="一、简介"><strong>一、简介</strong></h2> <p><strong>wx-hub</strong> 是一个 微信公众号内容半自动同步工具，可以快速通过微信链接同步其它公众号的文章信息。主要通过微信公众号的素材管理和草稿箱Api</p> <p><strong>wx-hub</strong> github地址:https://github.com/stilesTech/wx-hub</p> <p><strong>wx-operate-api</strong> github地址:https://github.com/stilesTech/wx-operate-api</p> <p>相关公众号接口文档：https://developers.weixin.qq.com/doc/offiaccount/Asset_Management/Adding_Permanent_Assets.html</p> <p>wx-operate-api 是wx-hub站点的后台支撑服务，需要添加对应的微信公众号配置才可以正常提供服务。相关配置如下图所示。</p> <p>微信后台配置：</p> <p><img src="http://stiles.cc/assets/img/2185062312.f1fe985b.png" alt="../uploads/2022/04/2185062312.png"></p> <p>wx-hub控制台配置:</p> <p><img src="http://stiles.cc/assets/img/3081734508.a37c9a78.png" alt="../uploads/2022/04/3081734508.png"></p> <h2 id="二、注意事项"><strong>二、注意事项</strong></h2> <p>注意1：两个服务都依赖数据库进行信息交换和传输，具体地址：https://github.com/stilesTech/wx-hub/blob/main/wx-hub-db.sql</p> <p>注意2：注意修改对应服务的数据库配置账号和密码。</p> <p>注意3：数据库默认后台登录账号admin,密码123456</p> <h2 id="三、如何部署"><strong>三、如何部署</strong></h2> <p>wx-hub:是.net core项目，wx-operate-api:是java spring boot项目，都支持容器化部署。</p> <p>对应步骤参考如下:</p> <p>wx-hub</p> <div class="language- extra-class"><pre class="language-text"><code>#构建docker image
docker build -t wx-hub:1.0.0 .
#登录docker仓库
docker login ip:port
#推送到对应镜像仓库
docker push ip:port/wx-hub:1.0.0
#docker部署
docker run -d -p 5001:80 --restart=always --name wx-hub wx-hub:1.0.0
</code></pre></div><p>wx-operate-api</p> <div class="language- extra-class"><pre class="language-text"><code>#需要先修改pom里面的docker仓库地址
mvn dockerfile:build -Pdev
mvn dockerfile:push -Pdev
</code></pre></div><h3 id="四、演示效果"><strong>四、演示效果</strong></h3> <p>输入地址： <a href="http://ip:port/" target="_blank" rel="noopener noreferrer">http://ip:port<span> </span></a> 访问,不同公众号需要自己调整公众号配置，具体效果如下：</p> <p>链接为对应需要同步的公众号文章链接。点击提交后即可同步对应文章内容到新的公众号。</p> <p><img src="http://stiles.cc/assets/img/4157468633.58bf7230.png" alt="../uploads/2022/04/4157468633.png"></p> <p><img src="http://stiles.cc/assets/img/1293486863.46ad1b3c.png" alt="../uploads/2022/04/1293486863.png"></p> <h2 id="五、其它问题"><strong>五、其它问题</strong></h2> <p>同步的图文封面地址怎么修改？</p> <p>一般情况用默认配置即可，有些特殊情况需要自定义设置，可以做如下配置：公众号的同步的图文的文章地址需要在公众号配置里面配置，如果没有配置默认走后台配置列表里面的default_article_cover的值。</p> <p>是否可以配置多个公众号？</p> <p>是可以的，不同公众号是需要在对应的微信公众号后台配置相同的配置信息。</p> <p>wx-hub是怎么指定wx-operate-api地址的？</p> <p>这个是在后台默认配置列表里面的service_url地址指定的。</p> <p>为何使用两个不同的技术来实现？</p> <p>个人即兴的开发同步工具，没有投入太多的时间，所以有个人的原因。</p> <p>其它问题可以联系我进行询问，如回复不及时还请谅解。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[恰如其分的代码]]></title>
            <link>http://stiles.cc/docs/coding/%E6%81%B0%E5%A6%82%E5%85%B6%E5%88%86%E7%9A%84%E4%BB%A3%E7%A0%81.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/coding/%E6%81%B0%E5%A6%82%E5%85%B6%E5%88%86%E7%9A%84%E4%BB%A3%E7%A0%81.html</guid>
            <pubDate>Sun, 27 Mar 2022 12:10:06 GMT</pubDate>
            <content:encoded><![CDATA[ <p>从业多年，也接触过java,c#,go,php,python,js等多种编程语言，每一种语言都能实现既定的业务逻辑，抛开底层运行原理来说，并没有丝毫的不同。 所以说代码之美应该超越边界之外来思考。一件事情的答案也许总是在更大的一个逻辑层面得到很好的解释。</p> <p>好比买一张桌子，其实不单单应该考虑的座子的整体舒适度，用料。更应该搭配到整个房间的布局上。</p> <p>很难说清楚一个代码片段的优秀与否。更应该讨论的是在整个服务乃至系统中的整体价值，是否做到了解耦（易修改，高度自治，不会有修改蔓延等问题），是否遵循设计原则（SOLID）做到了关注点分离（控制与逻辑业务的分离）。</p> <p>有位文豪说得好：“看一个作家的水平，不是看他发表了多少文字，而要看他的废纸篓里扔掉了多少。” 我觉得同样的理论适用于编程。好的程序员，他们删掉的代码，比留下来的还要多很多。如果你看见一个人写了很多代码，却没有删掉多少，那他的代码一定有很多垃圾。<a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.yinwang.org%2Fblog-cn%2F2015%2F11%2F21%2Fprogramming-philosophy" target="_blank" rel="noopener noreferrer">— 王垠的博客<span> </span></a></p> <p>写到这里想起了《代码整洁之道》的一个片段</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code>鲍勃进入模块。
他向下滚动到要修改的函数。
他停下来考虑可以做什么。
哦，他滚动到模块顶端，检查变量初始化。
现在他回到修改处，开始键入。
喔，他删掉了键入的内容。
他重新键入。
他又删除了！
他键入了一半什么东西，又删除掉。
他滚动到调用要修改函数的另一函数，看看是怎么调用的。
他回到修改处，重新键入刚才删掉的代码。
他停下来。
他再一次删掉代码！
他打开另一个窗口，查看别的子类，那是个负载函数吗？
…
复制代码
</code></pre></div><p>相信只要是工作过几个年头的程序员都有这样的经历，项目过程中花了大量的时间在阅读和理解系统代码的细节。良好的<strong>分离关注点</strong>，分层模块，就能极大的减少修改的担忧，也提升了代码的整洁性，为读者而写代码就能极大的提高后续的工作效率，即便那会使得编写过程更难。优秀的代码几乎都是不断演进提炼的，不可能一蹴而就。</p> <p>物皆有其位，而后物尽归其位，不要陷入到思考的误区，书写糟糕的代码只会影响您的工作。走快的唯一方法是先走好。工程师就有义务去梳理其中的恰如其分，使得读者赏心悦目。</p> <p><strong>总结：</strong></p> <p>如果说代码的恰如其分我想那就是阅读代码的人能一目了然，无需花费很多时间分析其中的不当之处。并无多少自己的东西，只是恰如其分的使用了一些老的论点来聊一聊自己对于优秀的代码的理解。希望能对您有所启发。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[分布式理论基础]]></title>
            <link>http://stiles.cc/docs/java/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/java/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</guid>
            <pubDate>Wed, 30 Jun 2021 02:36:01 GMT</pubDate>
            <content:encoded><![CDATA[ <p>提到分布式架构就一定绕不开“一致性”问题,分布式的理论必须要了解的点包括ACID、CAP、BASE、强一致性、弱一致性、最终一致性。</p> <p><strong>主要内容包括</strong></p> <p>1.了解分布式事务产生的原因</p> <p>2.知道几种分布式事务解决方案：XA、TCC、消息事务、TA、SAGA</p> <p>3.知道分布式事务各种解决方案的优缺点和使用场景</p> <h2 id="分布式事务产生的原因"><strong>分布式事务产生的原因</strong></h2> <p>要了解分布式事务产生的原因，先来说说本地事务事务是指由一系列严密的操作组成的一个完整的逻辑过程，这个过程中的所有操作要么都成功，要么都不成功。而本地事务，是指传统的<strong>单机数据库事务</strong>，必须具备ACID原则</p> <p><strong>本地事务ACID原则</strong></p> <p>ACID是事务的四个特性，指的是atomicity，原子性；consistency，一致性；isolation，隔离性；durability，持久性。</p> <ol><li>原子性(atomicity): 指所有在事务中的操作要么都成功，要么都不成功，所有的操作都不可分割，没有中间状态。一旦某一步执行失败，就会全部回滚到初始状态。</li> <li>一致性(consistency): 指的是逻辑上的一致性，即所有操作是符合现实当中的期望的。</li> <li>隔离性(isolation): 即不同事务之间的相互影响和隔离的程度。比如，不同的隔离级别，事务的并发程度也不同，最强的隔离状态是所有的事务都是串行化的（serializable）（即一个事务完成之后才能进行下一个事务），这样并发性也会降到最低，在保证了强一致性的情况下，性能也会受很大影响，所以在实际工程当中，往往会折中一下。</li> <li>持久性(durability): 可以简单地理解为事务执行完毕后数据不可逆并持久化存储于存储系统当中满足ACID原则的一个逻辑操作就可以成为一个本地事务。</li></ol> <p><strong>分布式事务</strong>分布式事务分布式事务，就是指不是在单个服务或单个数据库架构下，产生的事务：跨数据源的分布式事务跨服务的分布式事务两种情况交错的复杂情况</p> <p><strong>跨数据源</strong>随着业务数据规模的快速发展，数据量越来越大，单库单表逐渐成为瓶颈。所以我们对数据库进行了水平拆分，将原单库单表拆分成数据库分片，于是就产生了跨数据库事务问题。</p> <p><strong>跨服务</strong>随着业务的快速发展，系统的访问量和业务复杂程度都在快速增长，单系统架构逐渐成为业务发展瓶颈,按照面向服务（SOA）的架构的设计原则，将单业务系统拆分成多个业务系统，降低了各系统之间的耦合度，使不同的业务系统专注于自身业务，更有利于业务的发展和系统容量的伸缩</p> <p><strong>分布式事务一致性问题</strong></p> <p>1.单个本地事务可以保证ACID原则</p> <p>2.多个服务之间的“业务”的原子性保证,要么全部成功要么全部失败，这就是分布式系统下的事务了。</p> <p>3.此时ACID难以满足，这是分布式事务要解决的问题比如：订单生成了，库存也扣减了，但是用户账户的余额不足，这就造成数据不一致。订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个本地事务，可以保证ACID原则。但是当我们把三件事情看做一个事情事，要满足保证“业务”的原子性，要么所有操作全部成功，要么全部失败，这就要需要考虑使用分布式事务来解决数据一致性问题的场景了。</p> <p><img src="http://stiles.cc/assets/img/2778308107.341b1d46.png" alt="../uploads/2021/06/2778308107.png"></p> <p><img src="http://stiles.cc/assets/img/1633853993.5fcb91a8.png" alt="../uploads/2021/06/1633853993.png"></p> <p><img src="http://stiles.cc/assets/img/4282648972.0889c4ae.png" alt="../uploads/2021/06/4282648972.png"></p> <h1 id="解决分布式系统的思路"><strong>解决分布式系统的思路</strong></h1> <p><strong>CAP定理Base理论</strong></p> <h2 id="cap定理"><strong>CAP定理</strong></h2> <p>本小节内容摘自：<a href="https://www.ruanyifeng.com/blog/2018/07/cap.html" target="_blank" rel="noopener noreferrer">CAP 定理的含义<span> </span></a></p> <p><strong>什么是CAP定理呢？</strong></p> <p><img src="http://stiles.cc/assets/img/220743591.985f6a72.png" alt="../uploads/2021/06/220743591.png"></p> <p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</p> <ul><li><p>Consistency（一致性）</p></li> <li><p>Availability（可用性）</p></li> <li><p>Partition tolerance （分区容错性）它们的第一个字母分别是 C、A、P。Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</p></li> <li><p><strong>Partition tolerance</strong></p></li> <li><p>先看 Partition tolerance，中文叫做"分区容错"。大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在上海，另一台服务器放在北京，这就是两个区，它们之间可能因网络问题无法通信。如图：</p> <p><img src="http://stiles.cc/assets/img/1603730816.93684ede.png" alt="../uploads/2021/06/1603730816.png"></p></li></ul> <p>上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。</p> <p>一般来说，分布式系统，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。根据CAP 定理，剩下的 C 和 A 无法同时做到。</p> <p><strong>Consistency</strong></p> <p>Consistency 中文叫做"一致性"。意思是，写操作之后的读操作，必须返回该值。举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。</p> <p><img src="http://stiles.cc/assets/img/1517800247.36c2d9a3.png" alt="../uploads/2021/06/1517800247.png"></p> <p>接下来，用户的读操作就会得到 v1。这就叫一致性。</p> <p><img src="http://stiles.cc/assets/img/140579193.3360a80e.png" alt="../uploads/2021/06/140579193.png"></p> <p>问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。</p> <p><img src="http://stiles.cc/assets/img/1214249209.ce4a9fba.png" alt="../uploads/2021/06/1214249209.png"></p> <p>为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。</p> <p><img src="http://stiles.cc/assets/img/1273867568.b36d250e.png" alt="../uploads/2021/06/1273867568.png"></p> <p><img src="http://stiles.cc/assets/img/3931568903.2c6c66ed.png" alt="../uploads/2021/06/3931568903.png"></p> <p>这样的话，用户向 G2 发起读操作，也能得到 v1。</p> <p><strong>Availability</strong></p> <p>Availability 中文叫做"可用性"，意思是只要收到用户的请求，服务器就必须给出回应（对和错不论）。</p> <p>用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。</p> <p><strong>Consistency 和 Availability 的矛盾</strong></p> <p>一致性和可用性，为什么不可能同时成立？</p> <p>答案很简单，因为可能通信失败（即出现分区容错）。</p> <p>如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性不。</p> <p>如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。</p> <p>综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。</p> <h2 id="base理论"><strong>Base理论</strong></h2> <p>BASE是三个单词的缩写：</p> <ul><li>Basically Available（基本可用）</li> <li>Soft state（软状态）</li> <li>Eventually consistent（最终一致性）而我们解决分布式事务，就是根据上述理论来实现。还以上面的下单减库存和扣款为例：订单服务、库存服务、用户服务及他们对应的数据库就是分布式应用中的三个部分。</li> <li>CP方式：现在如果要满足事务的强一致性，就必须在订单服务数据库锁定的同时，对库存服务、用户服务数据资源同时锁定。等待三个服务业务全部处理完成，才可以释放资源。此时如果有其他请求想要操作被锁定的资源就会被阻塞，这样就是满足了CP。这就是强一致，弱可用</li> <li>AP方式：三个服务的对应数据库各自独立执行自己的业务，执行本地事务，不要求互相锁定资源。但是这个中间状态下，我们去访问数据库，可能遇到数据不一致的情况，不过我们需要做一些后补措施，保证在经过一段时间后，数据最终满足一致性。这就是高可用，但弱一致（最终一致）。由上面的两种思想，延伸出了很多的分布式事务解决方案：</li> <li>XA 方案</li> <li>TCC 方案</li> <li>SAGA 方案</li> <li>本地消息表</li> <li>可靠消息最终一致性方案</li> <li>最大努力通知方案</li></ul> <p>本文先说下XA(二阶段提交),和TCC方案，其它内容后续会继续更新。</p> <p><strong>二阶段提交/XA方案(2PC)</strong></p> <p>所谓的XA方案，即：两阶段提交，二阶段提交引入一个事务协调者角色来协调管理各个参与者的提交和回滚。二阶段分别指：准备（投票），提交两个阶段</p> <p>第一阶段：所有事务参与者，执行后进行预提交,也就是预留事务所需的资源；直到协调者收到所有参与者的预提交才会进入第二步；</p> <ul><li><p>如果在协调者的超时时间内，有任意参与者的预提交preCommit没发送或未到达，都会结束事务。第二阶段：所有事务预提交了各自的结果后，由协调者决定最终事务是成功(commit)还是失败(rollback)。准备阶段提交阶段二阶段提交的问题</p> <p><img src="http://stiles.cc/assets/img/1680163401.c144f7c0.jpg" alt="../uploads/2021/06/1680163401.jpg"></p> <p><img src="http://stiles.cc/assets/img/248721170.9bbabc51.jpg" alt="../uploads/2021/06/248721170.jpg"></p></li></ul> <p>1.执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p> <p>2.参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。（没有多少容错机制）。</p> <p>3.二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交，事务容易处于悬而未决的状态。</p> <p>4.效率比较低，不适合高并发场景</p> <p>Spring Boot + JTA 可以实现二阶段提交：</p> <p>参考地址：https://www.hifreud.com/2017/07/12/spring-boot-23-jta-handle-distribute-transaction/</p> <h2 id="tcc-try-confirm-cancel"><strong>TCC（Try-Confirm-Cancel）</strong></h2> <p>TCC 三个方法描述：</p> <ul><li><p>Try：资源的检测和预留(锁定)；</p></li> <li><p>Confirm：执行实际的业务操作提交；要求 Try 成功 Confirm 一定要能成功；</p></li> <li><p>Cancel：如果任一服务执行出错，那么进行补偿，业务回滚，预留资源释放；</p> <p><img src="http://stiles.cc/assets/img/1981845792.63ec5d43.png" alt="../uploads/2021/06/1981845792.png"></p></li></ul> <p><strong>TCC优缺点</strong></p> <ul><li>优势TCC执行的每一个阶段都会提交本地事务并释放锁，并不需要等待其它事务的执行结果。而如果其它事务执行失败，最后不是回滚，而是执行补偿操作。这样就避免了资源的长期锁定和阻塞等待，执行效率比较高，属于性能比较好的分布式事务方式。</li> <li>缺点代码侵入：需要人为编写代码实现try、confirm、cancel，代码侵入较多开发成本高：一个业务需要拆分成3个步骤，分别编写业务实现，业务编写比较复杂安全性考虑：cancel动作如果执行失败，资源就无法释放，需要引入重试机制，而重试可能导致重复执行，还要考虑重试时的幂等问题</li></ul> <p><strong>TCC使用场景</strong>•对事务有一定的一致性要求（最终一致）•对性能要求较高•开发人员具备较高的编码能力和幂等处理经验</p> <p>内容之外的一个经典又有趣的问题。</p> <h2 id="二将军问题-two-generals-problem"><strong>二将军问题（Two Generals Problem）</strong></h2> <p><img src="http://stiles.cc/assets/img/961209882.b1589229.jpg" alt="../uploads/2021/06/961209882.jpg"></p> <p>如图所示，白军驻扎在沟渠里，蓝军则分散在沟渠两边。白军比任何一支蓝军都更为强大，但是蓝军若能同时合力进攻则能够打败白军。他们不能够远程的沟通，只能派遣通信兵穿过沟渠去通知对方蓝军协商进攻时间。是否存在一个能使蓝军必胜的通信协议，这就是两军问题。</p> <p>必须注意的是，通信兵得经过敌人的沟渠，在这过程中他可能被捕,也就是说，两军问题中信道是不可靠的，并且其中没有叛徒之说.</p> <p>倘若1号蓝军（简称1）向2号蓝军（简称2）派出了通信兵，若1要知道2是否收到了自己的信息，1必须要求2给自己传输一个回执，说“你的信息我已经收到了，我同意你提议的明天早上10点9分准时进攻”。</p> <p>然而，就算2已经送出了这条信息，2也不能确定1就一定会在这个时间进攻，因为2发出的回执1并不一定能够收到。所以，1必须再给2发出一个回执说“我收到了”，但是1也不会知道2是否收到了这样一个回执，所以1还会期待一个2的回执。</p> <p>二将军问题很好的说明了网络传输是不可靠的。</p> <h2 id="总结-什么是分布式事务"><strong>总结-什么是分布式事务</strong></h2> <p>在一个分布式系统中各个数据节点之间数据的ACID特性保证.通过事务拆分，和事件补偿的方法来保证分布式事务的一致性。</p> <p>解决方案:</p> <p><strong>拆分:</strong></p> <p>1.分布式事务-》长事务</p> <p>2.本地事务-》短事务</p> <p>3.长事务拆分多个短事务</p> <p><strong>补偿:</strong></p> <p>A-&gt;B-&gt;C</p> <p>A,B成功,C失败</p> <p>•C不需要补偿</p> <p>•补偿B,A</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用kubewatch监控k8s资源变更]]></title>
            <link>http://stiles.cc/docs/engineering/%E4%BD%BF%E7%94%A8kubewatch%E7%9B%91%E6%8E%A7k8s%E8%B5%84%E6%BA%90%E5%8F%98%E6%9B%B4.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/engineering/%E4%BD%BF%E7%94%A8kubewatch%E7%9B%91%E6%8E%A7k8s%E8%B5%84%E6%BA%90%E5%8F%98%E6%9B%B4.html</guid>
            <pubDate>Fri, 04 Jun 2021 10:32:08 GMT</pubDate>
            <content:encoded><![CDATA[ <h2 id="kubewatch"><strong>kubewatch</strong></h2> <p>kubewatch是一个用 Go 编写并由 Bitnami Labs 开发的开源 Kubernetes 资源监控观察器。它监视指定的 Kubernetes 资源的更改，再通过handler 将这些变化以通知的形式发布到可用的渠道，例如Slack、Hipchat 等。也可以在应用程序中通过Webhook 的方式来收听kubewatch 发出的状态变化通知。</p> <p><img src="http://stiles.cc/assets/img/576582101.f066ce27.png" alt="../uploads/2021/06/576582101.png"></p> <p>您可以通过 kubectl 或使用 helm charts 安装 Kubewatch。它易于理解并且具有非常易于使用的界面。除了 slack，它还支持 HipChat、Mattermost、Flock、webhook 和 SMTP。</p> <p>根据您要监控的 Kubernetes，您可以在 ConfigMap 文件中为这些资源设置 true 或 false。设置 kubewatch 配置并运行 pod 后，您将开始接收有关 Kubernetes 事件的通知.</p> <p>基于kubectl的安装方式如下,其它方式可参考 github地址：https://github.com/bitnami-labs/kubewatch具体配置如下,添加资源权限创建文件rbac.yaml,内容如下</p> <div class="language- extra-class"><pre class="language-text"><code>apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: system:kubewatch
  namespace: monitoring
rules:
  - apiGroups:
      - ""
      - "apps"
    resources:
      - endpoints
      - services
      - pods
      - namespaces
      - replicationcontrollers
      - configmaps
      - replicasets
      - secrets
      - deployments
      - daemonsets
    verbs:
      - list
      - watch
      - get
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: system:kubewatch
  namespace: monitoring
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:kubewatch
subjects:
  - kind: ServiceAccount
    name: kubewatch
    namespace: monitoring
</code></pre></div><p>执行以下命令创建资源:</p> <div class="language- extra-class"><pre class="language-text"><code>kubectl create -f rbac.yaml
</code></pre></div><p>部署kubewatch, 创建如下文件kubewatch-deploy.yaml</p> <div class="language- extra-class"><pre class="language-text"><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: kubewatch
  namespace: monitoring
data:
  .kubewatch.yaml: |
    handler:
      webhook:
        url: "&lt;http://xxx.xxx&gt;"
        enable: true
    resource:
      deployment: true
      replicationcontroller: true
      replicaset: false
      daemonset: true
      services: true
      pod: false
      secret: false
      configmap: false
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: kubewatch
  name: kubewatch
  namespace: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kubewatch
  template:
    metadata:
      labels:
        app: kubewatch
    spec:
      containers:
        - image: bitnami/kubewatch #using this image, its more stable and active
          imagePullPolicy: Always
          name: kubewatch
          volumeMounts:
            - name: config-volume
              # mountPath: /root
              mountPath: /opt/bitnami/kubewatch/.kubewatch.yaml
              subPath: .kubewatch.yaml
      restartPolicy: Always
      serviceAccount: kubewatch
      serviceAccountName: kubewatch
      volumes:
        - name: config-volume
          configMap:
            name: kubewatch
</code></pre></div><p><strong>执行以下命令创建资源:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>kubectl create -f kubewatch-deploy.yaml
</code></pre></div><p>其它安装方式请参考：https://github.com/bitnami-labs/kubewatch</p> <h2 id="基于飞书配置webhook"><strong>基于飞书配置webhook</strong></h2> <p>地址：</p> <p>https://www.feishu.cn/hc/zh-CN/articles/360024984973</p> <p><img src="http://stiles.cc/assets/img/1803910136.a75853a0.png" alt="../uploads/2021/06/1803910136.png"></p> <p><img src="http://stiles.cc/assets/img/4131192128.b92e9dfb.png" alt="../uploads/2021/06/4131192128.png"></p> <p>配置 webhook。你会获取该机器人的 webhook 地址，格式如下：</p> <p>https://open.feishu.cn/open-apis/bot/v2/hook/xxxxxxxxxxxxxxxxx</p> <p>复制此地址，在相关外部系统中进行配置，以向本群发送消息。请妥善保存好此地址，避免地址泄露后被恶意调用发送垃圾消息。</p> <p><img src="http://stiles.cc/assets/img/2144574114.da464976.png" alt="../uploads/2021/06/2144574114.png"></p> <ul><li>飞书需要使用post方式，真正对接过程中需要用接口中转下真正的请求。</li></ul> <p>具体可自行实现。</p> <p>最后kubernetes资源变更时会收到如下通知,结果如下：</p> <p><img src="http://stiles.cc/assets/img/4041782526.cc8f8ae3.png" alt="../uploads/2021/06/4041782526.png"></p> <h2 id="webhook对接细节"><strong>webhook对接细节</strong></h2> <p>kubewatch触发webhook监控后，发送的内容通过body里面的二进制传输，这个比较坑，文档不够齐全，找了半天才发现，具体可查看源码。</p> <p>body内容解析后格式如下</p> <div class="language- extra-class"><pre class="language-text"><code>{
    "eventmeta": {
        "kind": "pod",
        "name": "monitoring/kubewatch",
        "namespace": "",
        "reason": "updated"
    },
    "text": "A `pod` in namespace `` has been `updated`:\\n`monitoring/kubewatch`",
    "time": "2021-06-03T05:42:16.7812141Z"
}
</code></pre></div><p><strong>参考资料</strong></p> <p>https://medium.com/@harsh.manvar111/kubernetes-event-notifications-1b2fb12a30ce</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Liquibase简单介绍与使用]]></title>
            <link>http://stiles.cc/docs/engineering/Liquibase%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/engineering/Liquibase%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8.html</guid>
            <pubDate>Mon, 05 Apr 2021 02:30:26 GMT</pubDate>
            <content:encoded><![CDATA[ <h2 id="liquibase还是flyway">Liquibase还是Flyway</h2> <p>Flyway和Liquibase都支持专业数据库重构和版本控制所需的所有功能，因此您将始终知道要处理的数据库模式的版本以及它是否与软件版本匹配。两种工具都集成在Maven或Gradle构建脚本中以及Spring Boot生态系统中，您可以完全自动化数据库重构。</p> <p>Flyway使用SQL定义数据库更改，因此您可以定制SQL脚本，使其与基础数据库技术（例如Oracle或PostgreSQL）良好地配合使用。另一方面，使用Liquibase，您可以通过使用XML，YAML或JSON来定义数据库更改来引入抽象层。因此，Liquibase更适合在具有不同基础数据库技术的不同环境中安装的软件产品中使用。但是，如果您想完全控制SQL，Flyway是首选工具，因为您可以使用完全定制的SQL甚至Java代码来更改数据库。</p> <p>多种数据源的情况下使用Liquibase会更加合适，不需要维护多种数据库脚本，和学习多种数据库语言，Liquibase对于大型项目更加友好。</p> <h2 id="什么是liquibase">什么是Liquibase</h2> <p>Liquibase是一个用于跟踪、管理和应用数据库变化的开源的数据库重构工具。它将所有数据库的变化（包括结构和数据）都保存在 changelog 文件中，便于版本控制，它的目标是提供一种数据库类型无关的解决方案，通过执行 schema 类型的文件来达到迁移。</p> <p>官网：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.liquibase.com%2F" target="_blank" rel="noopener noreferrer">docs.liquibase.com/<span> </span></a> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f1605123da94acdb4a7a9a7b7907c1e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="1617546202(1).jpg"></p> <h2 id="使用liquibase的数据库的ci-cd">使用Liquibase的数据库的CI / CD</h2> <p>实施端到端CI / CD要求将所有代码（包括数据库代码）检入版本控制系统，并作为软件发布过程的一部分进行部署。Liquibase可以帮助您实现这一目标。
您使用Liquibase进行的每个数据库架构更改都称为一个changeset。Liquibase使用changelogs跟踪所有变更集。Liquibase允许您创建一个触发器，该触发器通过指向更改日志文件来自动更新数据库。从这里，可以轻松地将流程集成到您的整个CI / CD流程中：</p> <p>1.将变更集文件推送到要素存储库</p> <p>2.针对Dev分支创建拉取请求</p> <p>3.在同行评审和批准之后，将功能分支与开发分支合并</p> <p>4.在Dev服务器上配置的CI / CD实现触发Liquibase进行数据库更新</p> <p>5.Liquibase会自动执行任何新的变更日志文件（而且足以记住已经运行了哪些脚本）</p> <h2 id="liquibase原理">Liquibase原理</h2> <p>liquibase支持XML、YAML和JSON格式的迁移脚本。
默认情况下，Bean会在/db/changelog（相对于Classpath根目录）里查找db.changelog-master.yaml文件。
Liquibase变更集都集中在一个文件里。changeset命令后的那行有一个id属性，要对数据库进行后续变更。可以添加一个新的changeset，只要id不一样就行。此外，id属性也不一定是数字，可以包含任意内容。
应用程序启动时，Liquibase会读取db.changelog-master.yaml里的变更集指令集，与之前写入databaseChangeLog表里的内容做对比，随后执行未运行过的变更集。</p> <h2 id="liquibase-特性">Liquibase 特性</h2> <ul><li>支持几乎所有主流的数据库，如 MySQL, PostgreSQL, Oracle, Sql Server, DB2 等；</li> <li>支持多开发者的协作维护；</li> <li>日志文件支持多种格式，如 XML, YAML, JSON, SQL等；</li> <li>支持上下文相关逻辑</li> <li>生成数据库变更文档</li> <li>支持多种运行方式，如命令行、Spring 集成、Maven 插件、Gradle 插件等。</li></ul> <h2 id="springboot-整合-liquibase">SpringBoot 整合 liquibase</h2> <p><strong>一、引入依赖先在 pom 文件里引入依赖</strong></p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.liquibase<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>liquibase-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><strong>二、指定配置文件位置</strong></p> <p>在代码中新建一个 LiquibaseConfig 类，用于配置 Liquibase，指定配置文件的位置。</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">import</span> javax<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>DataSource<span class="token punctuation">;</span>
<span class="token keyword">import</span> liquibase<span class="token punctuation">.</span>integration<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>SpringLiquibase<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span>

<span class="token annotation builtin">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> LiquibaseConfig <span class="token punctuation">{</span>

  <span class="token annotation builtin">@Bean</span>
  <span class="token keyword">public</span> SpringLiquibase <span class="token function">liquibase</span><span class="token punctuation">(</span>DataSource dataSource<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    SpringLiquibase liquibase <span class="token operator">=</span> new <span class="token function">SpringLiquibase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    liquibase<span class="token punctuation">.</span><span class="token function">setDataSource</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//指定changelog的位置，这里使用的一个master文件引用其他文件的方式</span>
    liquibase<span class="token punctuation">.</span><span class="token function">setChangeLog</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"classpath:liquibase/master.xml"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    liquibase<span class="token punctuation">.</span><span class="token function">setContexts</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"development,test,production"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    liquibase<span class="token punctuation">.</span><span class="token function">setShouldRun</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> liquibase<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p><strong>三、编写配置文件</strong></p> <p>目录结构：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4459593b38fd481ca7ccc76c13d61f45~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="liquibase.png">
src/main/resources 下新建一个文件夹：liquibase，用来存放跟 liquibase 相关的文件。
然后在 liquibase 文件夹下新建 master.xml 作为主文件。</p> <div class="language-ini extra-class"><pre class="language-ini"><code>&lt;databaseChangeLog
        <span class="token key attr-name">xmlns</span><span class="token punctuation">=</span><span class="token value attr-value">"<span class="token inner-value">http://www.liquibase.org/xml/ns/dbchangelog</span>"</span>
        <span class="token key attr-name">xmlns:xsi</span><span class="token punctuation">=</span><span class="token value attr-value">"<span class="token inner-value">http://www.w3.org/2001/XMLSchema-instance</span>"</span>
        <span class="token key attr-name">xsi:schemaLocation</span><span class="token punctuation">=</span><span class="token value attr-value">"http://www.liquibase.org/xml/ns/dbchangelog</span>
         http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"&gt;

    <span class="token key attr-name">&lt;includeAll path</span><span class="token punctuation">=</span><span class="token value attr-value">"liquibase/changelogs/" relativeToChangelogFile="false"/&gt;</span>

&lt;/databaseChangeLog&gt;
</code></pre></div><p>includeAll 标签可以把一个文件夹下的所有 changelog 都加载进来。如果单个加载可以用 include。
includeAll 标签里有两个属性：path 和 relativeToChangelogFile。</p> <table><thead><tr><th>Attribute</th> <th>Description</th></tr></thead> <tbody><tr><td>file</td> <td>指定要加载的文件或文件夹位置（在 include 标签里是 file）</td></tr> <tr><td>relativeToChangelogFile</td> <td>文件位置的路径是否相对于 root changelog 是相对路径，默认 false，即相对于 classpath 是相对路径。</td></tr></tbody></table> <p><strong>四、编写配置文件 changelog 介绍</strong></p> <div class="language-ini extra-class"><pre class="language-ini"><code><span class="token key attr-name">&lt;?xml version</span><span class="token punctuation">=</span><span class="token value attr-value">"1.0" encoding="UTF-8"?&gt;</span>
&lt;databaseChangeLog
        <span class="token key attr-name">xmlns</span><span class="token punctuation">=</span><span class="token value attr-value">"<span class="token inner-value">http://www.liquibase.org/xml/ns/dbchangelog</span>"</span>
        <span class="token key attr-name">xmlns:xsi</span><span class="token punctuation">=</span><span class="token value attr-value">"<span class="token inner-value">http://www.w3.org/2001/XMLSchema-instance</span>"</span>
        <span class="token key attr-name">xsi:schemaLocation</span><span class="token punctuation">=</span><span class="token value attr-value">"http://www.liquibase.org/xml/ns/dbchangelog</span>
         http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"&gt;

    <span class="token key attr-name">&lt;changeSet author</span><span class="token punctuation">=</span><span class="token value attr-value">"stiles" id="20210330-1" &gt;</span>
        <span class="token key attr-name">&lt;createTable tableName</span><span class="token punctuation">=</span><span class="token value attr-value">"department" remarks="部门表"&gt;</span>
            <span class="token key attr-name">&lt;column name</span><span class="token punctuation">=</span><span class="token value attr-value">"id" type="int" autoIncrement="true" &gt;</span>
                <span class="token key attr-name">&lt;constraints primaryKey</span><span class="token punctuation">=</span><span class="token value attr-value">"true" nullable="false"/&gt;</span>
            &lt;/column&gt;
            <span class="token key attr-name">&lt;column name</span><span class="token punctuation">=</span><span class="token value attr-value">"name" type="varchar(50)"&gt;</span>
                <span class="token key attr-name">&lt;constraints nullable</span><span class="token punctuation">=</span><span class="token value attr-value">"false"/&gt;</span>
            &lt;/column&gt;
            <span class="token key attr-name">&lt;column name</span><span class="token punctuation">=</span><span class="token value attr-value">"active" type="boolean" defaultValueBoolean="true"/&gt;</span>
        &lt;/createTable&gt;
    &lt;/changeSet&gt;
    <span class="token key attr-name">&lt;changeSet author</span><span class="token punctuation">=</span><span class="token value attr-value">"stiles" id="20210330-2" &gt;</span>
        <span class="token key attr-name">&lt;addColumn  tableName</span><span class="token punctuation">=</span><span class="token value attr-value">"department"&gt;</span>
            <span class="token key attr-name">&lt;column name</span><span class="token punctuation">=</span><span class="token value attr-value">"company"  type="VARCHAR(100)"&gt;&lt;/column&gt;</span>
        &lt;/addColumn&gt;
    &lt;/changeSet&gt;
    
    <span class="token key attr-name">&lt;changeSet author</span><span class="token punctuation">=</span><span class="token value attr-value">"stiles"  id="20210330-3"&gt;</span>
        <span class="token key attr-name">&lt;insert tableName</span><span class="token punctuation">=</span><span class="token value attr-value">"department"&gt;</span>
            <span class="token key attr-name">&lt;column name</span><span class="token punctuation">=</span><span class="token value attr-value">"id" valueNumeric="1"/&gt;</span>
            <span class="token key attr-name">&lt;column name</span><span class="token punctuation">=</span><span class="token value attr-value">"name" value="stiles_1"/&gt;</span>
            <span class="token key attr-name">&lt;column name</span><span class="token punctuation">=</span><span class="token value attr-value">"active" valueNumeric="1"/&gt;</span>
        &lt;/insert&gt;
        <span class="token key attr-name">&lt;insert tableName</span><span class="token punctuation">=</span><span class="token value attr-value">"department"&gt;</span>
            <span class="token key attr-name">&lt;column name</span><span class="token punctuation">=</span><span class="token value attr-value">"id" valueNumeric="2"/&gt;</span>
            <span class="token key attr-name">&lt;column name</span><span class="token punctuation">=</span><span class="token value attr-value">"name" value="stiles_2"/&gt;</span>
            <span class="token key attr-name">&lt;column name</span><span class="token punctuation">=</span><span class="token value attr-value">"active" valueNumeric="1"/&gt;</span>
        &lt;/insert&gt;
        <span class="token key attr-name">&lt;insert tableName</span><span class="token punctuation">=</span><span class="token value attr-value">"department"&gt;</span>
            <span class="token key attr-name">&lt;column name</span><span class="token punctuation">=</span><span class="token value attr-value">"id" valueNumeric="3"/&gt;</span>
            <span class="token key attr-name">&lt;column name</span><span class="token punctuation">=</span><span class="token value attr-value">"name" value="stiles_3"/&gt;</span>
            <span class="token key attr-name">&lt;column name</span><span class="token punctuation">=</span><span class="token value attr-value">"active" valueNumeric="0"/&gt;</span>
        &lt;/insert&gt;
    &lt;/changeSet&gt;
    <span class="token key attr-name">&lt;changeSet author</span><span class="token punctuation">=</span><span class="token value attr-value">"stiles" id="20210330-4" &gt;</span>
        <span class="token key attr-name">&lt;update tableName</span><span class="token punctuation">=</span><span class="token value attr-value">"department"&gt;</span>
            <span class="token key attr-name">&lt;column name</span><span class="token punctuation">=</span><span class="token value attr-value">"name" value="stiles_33"/&gt;</span>
            <span class="token key attr-name">&lt;where&gt;name</span><span class="token punctuation">=</span><span class="token value attr-value">'stiles_3'&lt;/where&gt;</span>
        &lt;/update&gt;
    &lt;/changeSet&gt;
&lt;/databaseChangeLog&gt;
</code></pre></div><p>SQL 格式的 changelogs 文件</p> <p>变更集 changeset 是通过 author + id 的方式来保证唯一性</p> <p>变更集提供以下属性：</p> <p>stripComments:设置为 true 可在执行之前删除 SQL 中的任何注释, 否则为 false。如果未设置, 则默认值为 true</p> <p>splitStatements:设置为false时，在“s”和“go”上不会使用Liquibase 拆分语句，默认为true。</p> <p>endDelimiter:应用于语句结尾的分隔符。默认为“；”，也可以设置为“”</p> <p>runAlways:在每次运行时执行变更集, 即使之前已运行</p> <p>runOnChange:在首次看到更改并每次更改变更集时执行更改</p> <p>context:如果在运行时传递了特定上下文, 则执行更改。任何字符串都可以用于上下文名称, 并且大小写不敏感。</p> <p>logicalFilePath:用于在创建变更集的唯一标识符时重写文件名和路径。移动或重命名更改日志时所必需。</p> <p>labels:标签是对变更集进行分类的通用方法集类似上下文, 但工作方式正好相反。如果不是在运行时定义一组上下文, 然后在变更集中定义一个匹配表达式, 而是在上下文中定义一组标签, 在运行时定义一个匹配表达式。</p> <p>runInTransaction:变更集是否应作为单个事务运行 (如果可能)，默认值为 true。请注意此属性，如果设置为 false, 并且通过运行包含多个语句的变更集部分发生错误, 则 liquibase 数据库的 databasechangeloglock 表将处于无效状态</p> <p>failOnError:如果在执行变更集时发生错误, 迁移是否应返回失败</p> <p>dbms:要用于该变更集的数据库的类型。当迁移步骤运行时, 它将根据此属性检查数据库类型，如：oracle、mysql</p> <p>logicalFilePath:在数据库 databasechangeloglock 中设置逻辑文件路径, 而不是在执行 liquibase 的 sql 物理文件位置。</p> <p><strong>五、Liquibase最佳实践</strong></p> <p>changelog管理建议：</p> <p><strong>一个变更集只设置一次更改</strong></p> <p>尽可能地避免对一个变更集进行多次更改，以避免自动提交 SQL 语句而可能使数据库处于非预期状态。 如 --changeset stiles:1 变更集，只新建一张 department 表，后面不再修改该变更集，如果需要变更，可以新增一条变更集。
变更集的 ID
选择适合您的方法。有的人是使用从 1 开始的序列号, 并且在更改日志中是唯一的，也有些人选择一个描述性的名称（例如：new-address-table）</p> <p><strong>总是考虑回滚</strong></p> <p>尽量尝试以可以回滚的方式编写变更集，如 --changeset stiles:1 变更集新建一个 department 表，在后面跟上回滚的 SQL， --rollback drop table department;</p> <p><strong>为变更集添加注释</strong></p> <p>尽量为每一个变更集条目增加注释</p> <p>演示案例：
<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FstilesBoy%2Fliquibase_example" target="_blank" rel="noopener noreferrer">github.com/stilesBoy/l…<span> </span></a></p> <p>参考资料：
<a href="https://link.juejin.cn?target=https%3A%2F%2Fthorben-janssen.com%2Fliquibase-update-existing-database%2F" target="_blank" rel="noopener noreferrer">thorben-janssen.com/liquibase-u…<span> </span></a> <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fcenxuu%2Farticle%2Fdetails%2F86685662" target="_blank" rel="noopener noreferrer">blog.csdn.net/cenxuu/arti…<span> </span></a> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.it610.com%2Farticle%2F1176477856620949504.htm" target="_blank" rel="noopener noreferrer">www.it610.com/article/117…<span> </span></a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[HTTP协议发展历程]]></title>
            <link>http://stiles.cc/docs/java/HTTP%E5%8D%8F%E8%AE%AE%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/java/HTTP%E5%8D%8F%E8%AE%AE%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.html</guid>
            <pubDate>Thu, 11 Feb 2021 04:26:00 GMT</pubDate>
            <content:encoded><![CDATA[ <p>HTTP代表(Hyper Text Transfer Protocol)超文本传输协议。是一种用于分布式、协作式和超媒体信息系统的应用层协议。网络协议很多种,HTTP是万维网的数据通信的基础。</p> <p>1996年,HTTP1.0协议规范<a href="http://www.ietf.org/rfc/rfc1945.txt" target="_blank" rel="noopener noreferrer">RFC1945<span> </span></a>发布.</p> <p>1999年,HTTP1.1协议规范<a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="noopener noreferrer">RFC2616<span> </span></a>发布.</p> <p>2015年,HTTP/2协议规范<a href="http://www.ietf.org/rfc/rfc7540.txt" target="_blank" rel="noopener noreferrer">RFC7540<span> </span></a>/<a href="http://www.ietf.org/rfc/rfc7541.txt" target="_blank" rel="noopener noreferrer">7541<span> </span></a>发布.</p> <ul><li>HTTP/2还没达到普及的程度,目前主流的协议还是HTTP1.1.</li></ul> <h2 id="http1-0"><strong>HTTP1.0</strong></h2> <p>HTTP1.0:无状态,无连接的应用层协议,客户端和服务端的通信每次请求都是“一来一回“的短链接,每发起一个请求时都会创建一个新的连接，并在收到应答时立即关闭。</p> <p>1:每次请求都是独立的(无状态)</p> <p>2:每次都创建一个新的TCP请求(无法复用)</p> <p>3:下个请求需要等待上个请求响应关闭完毕才能发送(队头阻塞)</p> <p><img src="http://stiles.cc/assets/img/1242166858.c3b01180.png" alt="../uploads/2021/02/1242166858.png"></p> <p>为了解决这些问题，</p> <div class="language- extra-class"><pre class="language-text"><code>HTTP1.1
</code></pre></div><p>出现了。</p> <h2 id="http1-1"><strong>HTTP1.1</strong></h2> <p>对于<code>HTTP1.1</code>，不仅继承了<code>HTTP1.0</code>简单的特点，还克服了诸多<code>HTTP1.0</code>性能上的问题。</p> <p>连接复用(<strong>长连接</strong>)</p> <p>HTTP1.1增加了一个Connection字段，通过设置<code>Keep-Alive</code>可以保持<code>HTTP</code>连接不断开，避免了每次客户端与服务器请求都要重复建立TCP连接，提高了网络的利用率。如果客户端想关闭HTTP连接，可以在请求头中携带<code>Connection: false</code> 来告知服务器关闭请求。</p> <ul><li>减少了建立和关闭连接的开销</li></ul> <p>管道化</p> <p><strong>Pipeline机制</strong></p> <p>在同一个Tcp连接上面,可以在请求发出去之后,响应没有回来之前,就可以发送下一个,再下一个请求,提高了在同一个Tcp连接上面的处理请求的效率,下图展示了串行和Pipeline对比.</p> <p><img src="http://stiles.cc/assets/img/4103234509.4de619d2.jpg" alt="../uploads/2021/02/4103234509.jpg"></p> <ul><li>提高单个TCP连接请求并发</li></ul> <p>需要注意的是，<strong>服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。</strong></p> <p>基于需要保证响应请求的顺序,故和HTTP1.0一样会有队头阻塞(Head-of-line Blocking)问题</p> <p>如上图如果请求1发生了延迟,那么请求2和请求3的响应会被阻塞,知道服务器返回请求1的响应</p> <p>也正因为如此,为了避免Pipeline机制的副作用,很多浏览器默认把Pipeline关闭了.</p> <p><strong>缓存处理（强缓存和协商缓存[<a href="http://www.yangzicong.com/article/12" target="_blank" rel="noopener noreferrer">传送门<span> </span></a>]）*<em>新的字段如<code>cache-control</code>，支持*<em>断点传输</em></em>，以及增加了</strong>Host字段**（使得一个服务器能够用来创建多个Web站点）。</p> <h2 id="http-2"><strong>HTTP/2</strong></h2> <p><strong>SPDY</strong></p> <p>SPDY是谷歌开发的一个实验性协议，于2009年年中发布，其主要目标是通过解决HTTP1.1中广为人知的一些性能限制，来减少网页的加载延迟。SPDY引入了一个新的二进制分帧数据层，以实现多向请求和响应、优先次序、最小化及消除不必要的网络延迟，目的是更有效利用底层TCP连接。</p> <p>几年后的2012年，这个新的实验性协议得到了Chrome、Firefox和Opera的支持，很多大型网站都对兼容客户端提供SPDY会话。最终，HTTP-WG在2012年吸取了SPDY的经验教训，并在此基础上制定了HTTP/2官方标准。</p> <p><img src="http://stiles.cc/assets/img/3067361075.e528b31e.jpg" alt="../uploads/2021/02/3067361075.jpg"></p> <p><strong>二进制分帧</strong>(解决队头阻塞问题)</p> <p>HTTP2.0通过在应用层和传输层之间增加一个二进制分帧层，突破了<code>HTTP1.1</code>的性能限制、改进传输性能</p> <p>HTTP1.1本身是明文的字符格式,所谓的二进制分帧,是指在把这个字符格式的报文给TCP之前转换成二进制,并且分成多个帧(多个数据块)来发送.</p> <p>帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</p> <p><img src="http://stiles.cc/assets/img/3331097472.d3467703.jpg" alt="../uploads/2021/02/3331097472.jpg"></p> <p><img src="http://stiles.cc/assets/img/3904546546.1a6ec46e.jpg" alt="../uploads/2021/02/3904546546.jpg"></p> <p>HTTP/2 把请求和响应通过</p> <p><strong>分帧</strong></p> <p>并且给每个帧打上流的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID 拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题。</p> <ul><li>并行交错地发送多个请求，请求之间互不影响。</li> <li>并行交错地发送多个响应，响应之间互不干扰。</li> <li>使用一个连接并行发送多个请求和响应。</li> <li>不必再为绕过 HTTP/1.x 限制而做很多工作（请参阅<a href="https://hpbn.co/optimizing-application-delivery/#optimizing-for-http1x" target="_blank" rel="noopener noreferrer">针对 HTTP/1.x 进行优化<span> </span></a>，例如级联文件、image sprites 和域名分片。</li> <li>消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间。</li> <li>等等...</li></ul> <p>有了二进制分帧,在HTTP层面请求和响应都是并发进行的</p> <p><img src="http://stiles.cc/assets/img/2010636137.d922ad52.jpg" alt="../uploads/2021/02/2010636137.jpg"></p> <p>更多细节:</p> <p><a href="https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn" target="_blank" rel="noopener noreferrer">点击<span> </span></a></p> <p><strong>HTTP发展历程</strong></p> <p><img src="http://stiles.cc/assets/img/2873103260.666dc5c9.jpg" alt="../uploads/2021/02/2873103260.jpg"></p> <h2 id="对比"><strong>对比</strong></h2> <p>HTTP 2.0 对 HTTP 的延迟问题起到了可以说是一个巨大的优化。下面的链接是网上的一个直观网站，它展示了同样是 300 多张图片，分别在 HTTP 1.1 和 HTTP 2.0 协议下加载的耗时。HTTP 2.0 的速度差不多是 HTTP 1.1 的6倍。</p> <p><a href="https://http2.akamai.com/demo" target="_blank" rel="noopener noreferrer">演示<span> </span></a></p> <p><img src="http://stiles.cc/assets/img/4089696677.7ef911c2.jpg" alt="../uploads/2021/02/4089696677.jpg"></p> <h2 id="总结"><strong>总结</strong></h2> <p>总结了下http的发展脉络希望对你有帮助</p> <p>*以上内容采集于网络由个人汇总整理,如有侵权请告知后及时删除.</p> <p>*转载：请注明出处 http://stiles.cc/archives/170/</p> <p><strong>参考文章</strong></p> <p>https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn</p> <p>https://juejin.cn/post/6844903796225785870</p> <p>https://book.douban.com/subject/30443578/</p> <p>https://segmentfault.com/a/1190000020042105</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[喜欢一个人的感觉有多美好]]></title>
            <link>http://stiles.cc/docs/thinking/%E5%96%9C%E6%AC%A2%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%84%9F%E8%A7%89%E6%9C%89%E5%A4%9A%E7%BE%8E%E5%A5%BD.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/thinking/%E5%96%9C%E6%AC%A2%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%84%9F%E8%A7%89%E6%9C%89%E5%A4%9A%E7%BE%8E%E5%A5%BD.html</guid>
            <pubDate>Wed, 03 Feb 2021 13:01:01 GMT</pubDate>
            <content:encoded><![CDATA[ <p>看到网易云的话题有感而发.</p> <p>还记得前天地铁里看到一对小情侣互相依偎,幸福感悠然而生,不由嘴角也漏出微笑.</p> <p><img src="http://stiles.cc/assets/img/572617274.8c691742.jpg" alt="../uploads/2021/02/572617274.jpg"></p> <p>喜欢一个人的感觉可以有多美好,我看过最好的解释</p> <h2 id="乍见心欢"><strong>乍见心欢</strong></h2> <p><img src="http://stiles.cc/assets/img/4241547425.759cf728.jpg" alt="../uploads/2021/02/4241547425.jpg"></p> <h2 id="小别思恋"><strong>小别思恋</strong></h2> <p><img src="http://stiles.cc/assets/img/2292517671.22c1615b.jpg" alt="../uploads/2021/02/2292517671.jpg"></p> <h2 id="久处仍怦然"><strong>久处仍怦然</strong></h2> <p><img src="http://stiles.cc/assets/img/2327678977.11e3603b.jpg" alt="../uploads/2021/02/2327678977.jpg"></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rabbitmq核心协议AMQP详解]]></title>
            <link>http://stiles.cc/docs/rabbitmq/Rabbitmq%E6%A0%B8%E5%BF%83%E5%8D%8F%E8%AE%AEAMQP%E8%AF%A6%E8%A7%A3.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/rabbitmq/Rabbitmq%E6%A0%B8%E5%BF%83%E5%8D%8F%E8%AE%AEAMQP%E8%AF%A6%E8%A7%A3.html</guid>
            <pubDate>Wed, 03 Feb 2021 12:48:01 GMT</pubDate>
            <content:encoded><![CDATA[ <p>RabbitMQ是使用Erlang语言编写，实现了高级消息队列协议（AMQP）的一款<strong>消息中间件</strong>。</p> <p><strong>AMQP是什么？</strong></p> <p>AMQP（<strong>Advanced Message Queuing Protocol</strong> 高级消息队列协议）是一个网络协议。它支持符合要求的客户端应用（application）和消息中间件代理（messaging middleware broker）之间进行通信。其设计目标是对于消息的排序、路由（包括点对点和订阅-发布）、保持可靠性、保证安全性.AMQP规范了消息传递方和接收方的行为，以使消息在不同的提供商之间实现互操作性，就像SMTP，HTTP，FTP等协议可以创建交互系统一样</p> <p><strong>历史</strong></p> <p>高级消息队列协议最早在2003年由John O'Hara在摩根大通提出。初始设计方案在2004年中至2006年中由摩根大通发布，由iMatix公司编写协议文档和一个C语言实现。2005年摩根大通推动了包括思科系统、红帽公司、iMatix、IONA技术等公司组成了一个工作组。摩根大通和红帽公司合作开发了Apache Qpid，该客户端最初由Java编写，后转向C++；Rabbit技术公司独立用Erlang开发了RabbitMQ。早先版本的协议包括版本0-8，2006年6月发布；版本0-92006年12月发布；版本0-9-12008年11月发布。这些版本与后来的1.0系列有很大的不同。2011年8月，高级消息队列协议工作组公布其改组方案，作为OASIS成员运作。2011年10月30日: 高级消息队列协议1.0版本。该版本在2014年四月成为ISO/IEC国际标准。*RabbitMQ 主要支持高级消息队列 0-9-1 版本，可以通过插件支持1.0版本协议。以下内容都是基于0-9-1版本讲解</p> <p><strong>消息代理和他们所扮演的角色</strong></p> <p>消息代理（message brokers）从发布者（publishers）亦称生产者（producers）那儿接收消息，并根据既定的路由规则把接收到的消息发送给处理消息的消费者（consumers）。由于AMQP是一个网络协议，所以这个过程中的发布者，消费者，消息代理 可以存在于不同的设备上。</p> <p>简单AMQP 0-9-1 模型</p> <p><img src="http://stiles.cc/assets/img/3536577404.61aa7ca7.png" alt="../uploads/2021/02/3536577404.png"></p> <p>消息（message）被发布者（publisher）发送给交换机（exchange），交换机常常被比喻成邮局或者邮箱。然后交换机将收到的消息根据路由规则分发给绑定的队列（queue）。最后AMQP代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。从安全角度考虑，网络是不可靠的，接收消息的应用也有可能在处理消息的时候失败。基于此原因，AMQP模块包含了一个消息确认（message acknowledgements）的概念：当一个消息从队列中投递给消费者后（consumer），消费者会通知一下消息代理（broker），这个可以是自动的也可以由处理消息的应用的开发者执行。当“消息确认”被启用的时候，消息代理不会完全将消息从队列中删除，直到它收到来自消费者的确认回执（acknowledgement）。在某些情况下，例如当一个消息无法被成功路由时，消息或许会被返回给发布者并被丢弃。或者，如果消息代理执行了延期操作，消息会被放入一个所谓的死信队列中。此时，消息发布者可以选择某些参数来处理这些特殊情况。队列，交换机和绑定统称为AMQP实体（AMQP entities）。</p> <p><strong>AMQP是一个可编程的协议</strong></p> <p>AMQP 0-9-1是一个可编程协议，某种意义上说AMQP的实体和路由规则是由应用本身定义的，而不是由消息代理定义。包括像声明队列和交换机，定义他们之间的绑定，订阅队列等等关于协议本身的操作。</p> <p><strong>交换机和交换机类型</strong></p> <p>交换机是用来发送消息的AMQP实体。交换机拿到一个消息之后将它路由给一个或零个队列。它使用哪种路由算法是由交换机类型和被称作绑定（bindings）的规则所决定的。AMQP 0-9-1的代理提供了四种交换机</p> <p>除交换机类型外，在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：</p> <ul><li><p>Name</p></li> <li><p>Durability （消息代理重启后，交换机是否还存在）</p></li> <li><p>Auto-delete （当所有与之绑定的消息队列都完成了对此交换机的使用后，删掉它）</p></li> <li><p>Arguments（依赖代理本身）交换机可以有两个状态：持久（durable）、暂存（transient）。持久化的交换机会在消息代理（broker）重启后依旧存在，而暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。然而并不是所有的应用场景都需要持久化的交换机。</p></li> <li><p><strong>默认交换机</strong></p></li> <li><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。它有一个特殊的属性使得它对于简单应用特别有用处：那就是每个新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。举个栗子：当你声明了一个名为"search-indexing-online"的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为"search-indexing-online"。因此，当携带着名为"search-indexing-online"的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为"search-indexing-online"的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。</p></li> <li><p><strong>直连交换机</strong></p></li> <li><p>直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。下边介绍它是如何工作的：</p></li> <li><p>将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）</p></li> <li><p>当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。直连交换机经常用来循环分发任务给多个工作者（workers）。当这样做的时候，我们需要明白一点，在AMQP 0-9-1中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。直连型交换机图例</p></li> <li><p><strong>主题交换机</strong></p></li> <li><p>主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候，主题交换机都可以被列入考虑范围。符号“#”:匹配一个或多个词符号“*”:匹配正好一个词使用案例：</p> <p><img src="http://stiles.cc/assets/img/2707927391.9136e402.png" alt="../uploads/2021/02/2707927391.png"></p> <p><img src="http://stiles.cc/assets/img/1501912413.d12a5e37.png" alt="../uploads/2021/02/1501912413.png"></p></li> <li><p>分发有关于特定地理位置的数据，例如销售点</p></li> <li><p>由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务</p></li> <li><p>股票价格更新（以及其他类型的金融数据更新）</p></li> <li><p>涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）</p></li> <li><p>云端的不同种类服务的协调</p></li> <li><p>分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。</p></li> <li><p><strong>头交换机</strong></p></li> <li><p>有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。我们可以绑定一个队列到头交换机上，并给他们之间的绑定使用多个用于匹配的头（header）。这个案例中，消息代理得从应用开发者那儿取到更多一段信息，换句话说，它需要考虑某条消息（message）是需要部分匹配还是全部匹配。上边说的“更多一段消息”就是"x-match"参数。当"x-match"设置为“any”时，消息头的任意一个值被匹配就可以满足条件，而当"x-match"设置为“all”的时候，就需要消息头的所有值都匹配成功。头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。</p></li> <li><p>any: 只要在发布消息时携带的有一对键值对headers满足队列定义的多个参数arguments的其中一个就能匹配上，注意这里是键值对的完全匹配，只匹配到键了，值却不一样是不行的；</p></li> <li><p>all：在发布消息时携带的所有Entry必须和绑定在队列上的所有Entry完全匹配</p></li> <li><p><strong>队列</strong></p></li> <li><p>AMQP中的队列（queue）跟其他消息队列或任务队列中的队列是很相似的：它们存储着即将被应用消费掉的消息。队列跟交换机共享某些属性，但是队列也有一些另外的属性。</p> <p><img src="http://stiles.cc/assets/img/1114539284.e8cd4d3b.png" alt="../uploads/2021/02/1114539284.png"></p></li> <li><p>Name</p></li> <li><p>Durable（消息代理重启后，队列依旧存在）</p></li> <li><p>Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）</p></li> <li><p>Auto-delete（当最后一个消费者退订后即被删除）</p></li> <li><p>Arguments（一些消息代理用他来完成类似与TTL的某些额外功能）队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。</p></li></ul> <p><strong>队列名称</strong></p> <p>队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。队列的名字可以是最多255字节的一个utf-8字符串。若希望AMQP消息代理生成队列名，需要给队列的name参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，我们可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。以"amq."开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403 (ACCESS_REFUSED)错误会被抛出。</p> <p><strong>队列持久化</strong></p> <p>持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。绑定绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。打个比方：</p> <p>队列（queue）是我们想要去的位于纽约的目的地</p> <p>交换机（exchange）是JFK机场</p> <p>绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。</p> <p><strong>消费者</strong></p> <p>消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。在AMQP 0-9-1 模型中，有两种途径可以达到此目的：</p> <p>将消息投递给应用 ("push API")</p> <p>应用根据需要主动获取消息 ("pull API")使用push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。每个消费者（订阅者）都有一个叫做消费者标签的标识符。它可以被用来退订消息。消费者标签实际上是一个字符串。</p> <p><strong>消息确认</strong></p> <p>消费者应用（Consumer applications） - 用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP代理在什么时候删除消息才是正确的？AMQP 0-9-1 规范给我们两种建议：</p> <p>当消息代理（broker）将消息发送给应用后立即删除。（使用AMQP方法：basic.deliver或basic.get-ok）</p> <p>待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用AMQP方法：basic.ack）前者被称作自动确认模式（automatic acknowledgement model），后者被称作显式确认模式（explicit acknowledgement model）。在显式模式下，由消费者应用来选择什么时候发送确认回执（acknowledgement）。应用可以在收到消息后立即发送，或将未处理的消息存储后发送，或等到消息被处理完毕后再发送确认回执（例如，成功获取一个网页内容并将其存储之后）。如果一个消费者在尚未发送确认回执的情况下挂掉了，那AMQP代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递</p> <p><strong>拒绝消息</strong></p> <p>当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。</p> <p><strong>预取消息</strong></p> <p>在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（？？？例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）注意，RabbitMQ只支持通道级的预取计数，而不是连接级的或者基于大小的预取。</p> <p><strong>消息确认</strong></p> <p>由于网络的不确定性和应用失败的可能性，处理确认回执（acknowledgement）就变的十分重要。有时我们确认消费者收到消息就可以了，有时确认回执意味着消息已被验证并且处理完毕，例如对某些数据已经验证完毕并且进行了数据存储或者索引操作。这种情形很常见，所以 AMQP 0-9-1 内置了一个功能叫做 消息确认（message acknowledgements），消费者用它来确认消息已经被接收或者处理。如果一个应用崩溃掉（此时连接会断掉，所以AMQP代理亦会得知），而且消息的确认回执功能已经被开启，但是消息代理尚未获得确认回执，那么消息会被从新放入队列（并且在还有还有其他消费者存在于此队列的前提下，立即投递给另外一个消费者）。协议内置的消息确认功能将帮助开发者建立强大的软件。</p> <p>AMQP 0-9-1 方法(操作)交换机类-方法（操作）</p> <ul><li><p>exchange.declare</p></li> <li><p>exchange.declare-ok</p></li> <li><p>exchange.delete</p></li> <li><p>exchange.delete-ok以上的操作来自逻辑上的配对：exchange.declare 和 exchange.declare-ok，exchange.delete 和 exchange.delete-ok. 这些操作分为“请求 - requests”（由客户端发送）和“响应 - responses”（由代理发送，用来回应之前提到的“请求”操作）。如下的例子：客户端要求消息代理使用exchange.declare方法声明一个新的交换机：如上图所示，exchange.declare方法携带了好几个参数。这些参数可以允许客户端指定交换机名称、类型、是否持久化等等。操作成功后，消息代理使用exchange.declare-ok方法进行回应：exchange.declare-ok方法除了通道号之外没有携带任何其他参数。AMQP队列类的配对方法 - queue.declare方法 和 queue.declare-ok有着与其他配对方法非常相似的一系列事件：不是所有的AMQP方法都有与其配对的“另一半”。许多（basic.publish是最被广泛使用的）都没有相对应的“响应”方法，另外一些（如basic.get）有着一种以上与之对应的“响应”方法。</p></li></ul> <p><strong>连接</strong></p> <p>AMQP连接通常是长连接。AMQP是一个使用TCP提供可靠投递的应用层协议。AMQP使用认证机制并且提供TLS（SSL）保护。当一个应用不再需要连接到AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。</p> <p><strong>通道</strong></p> <p>有些应用需要与AMQP代理建立多个连接。无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。在涉及多线程/进程的应用中，为每个线程/进程开启一个通道（channel）是很常见的，并且这些通道不能被线程/进程共享。一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。</p> <p><strong>虚拟主机</strong></p> <p>为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟Web servers虚拟主机概念非常相似，这为AMQP实体提供了完全隔离的环境。当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。</p> <p><img src="http://stiles.cc/assets/img/588350871.69e26c48.png" alt="../uploads/2021/02/588350871.png"></p> <p><img src="http://stiles.cc/assets/img/3051215053.2a3a6dcc.png" alt="../uploads/2021/02/3051215053.png"></p> <p><img src="http://stiles.cc/assets/img/3941920383.84371020.png" alt="../uploads/2021/02/3941920383.png"></p> <p><img src="http://stiles.cc/assets/img/311290923.e7f3b4c0.png" alt="../uploads/2021/02/311290923.png"></p> <p>参考链接：</p> <p>AMQP 0-9-1 Model Explained：https://www.rabbitmq.com/tutorials/amqp-concepts.html</p> <ul><li>以上内容采集于网络由个人汇总整理,如有侵权请告知后及时删除.转载：请注明出处 http://stiles.cc/archives/152/</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Prometheus监控介绍]]></title>
            <link>http://stiles.cc/docs/java/Prometheus%E7%9B%91%E6%8E%A7%E4%BB%8B%E7%BB%8D.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/java/Prometheus%E7%9B%91%E6%8E%A7%E4%BB%8B%E7%BB%8D.html</guid>
            <pubDate>Fri, 18 Dec 2020 13:06:00 GMT</pubDate>
            <content:encoded><![CDATA[ <p><strong>1：Prometheus简介：</strong></p> <p>既是一个时序数据库，又是一个监控系统，更是一套开源的完备监控生态解决方案。</p> <p>Prometheus受启发于Google的Brogmon监控系统,从2012年开始由前Google工程师在Soundcloud以开源软件的形式进行研发，并且于2015年早期对外发布早期版本。2016年5月继Kubernetes之后成为第二个正式加入CNCF基金会的项目，同年6月正式发布1.0版本。2017年底发布了基于全新存储层的2.0版本，能更好地与容器平台、云平台配合。</p> <p><strong>作为时序数据库</strong></p> <p>点击链接查看排名：https://db-engines.com/en/ranking/time+series+dbms</p> <p><img src="http://stiles.cc/assets/img/3797798294.fd1b1fe3.png" alt="../uploads/2020/12/3797798294.png"></p> <p><strong>作为监控系统</strong></p> <p>它从应用程序中实时获取时间序列数据，然后通过功能强大的规则引擎，帮助你识别监控环境所需的信息。</p> <p>特点：</p> <p>1：通过PromQL实现多维度数据模型的灵活查询。</p> <p>2：定义了开放指标数据的标准，自定义探针（如Exporter等），编写简单方便。</p> <p>3：PushGateway组件让这款监控系统可以接收监控数据。</p> <p>4：提供了VM和容器化的版本。</p> <p>5：采用拉模式为主、推模式为辅的方式采集数据。</p> <p>6：支持多种语言的客户端，如Java、JMX、Python、Go、Ruby、.NET、Node.js等语言。</p> <p>7：支持本地和第三方远程存储，单机性能强劲，可以处理上千target及每秒百万级时间序列。</p> <p>8：高效的存储。平均一个采样数据占3.5B左右，共320万个时间序列，每30秒采样一次，如此持续运行60天，占用磁盘空间大约为228GB（有一定富余量，部分要占磁盘空间的项目未在这里列出）</p> <p>9：出色的可视化功能。Prometheus拥有多种可视化的模式，比如内置表达式浏览器、Grafana集成和控制台模板语言。它还提供了HTTP查询接口，方便结合其他GUI组件或者脚本展示数据。不一一列举</p> <p>下图是prometheus的体系结构和对应的生态组件</p> <p><img src="http://stiles.cc/assets/img/4182706.9d3b96b9.png" alt="../uploads/2020/12/4182706.png"></p> <p>prometheus是一个开源的监控告警系统，具有由度量名称和键/值对标识的时间序列数据的多维数据模型、灵活的查询语言，监控模式是通过HTTP主动去拉取exporters上基于时间序列的监控采集数据，同时也能通过中间网关来支持推送型的监控数据收集，所有的监控目标都是通过配置型的或是服务发现，或是静态配置，提供了HTTP页面支持图形和仪表盘的展示。</p> <p><strong>2：什么是Prometheus Operator</strong></p> <p>Git 地址：https://github.com/prometheus-operator/prometheus-operatorpromethues-operator是一个通过监听K8s内CRD资源的变更操作事件来自动创建，配置并管理prometheus监控系统的一个控制器。</p> <p>为了在Kubernetes能够方便的管理和部署Prometheus，我们使用ConfigMap来管理Prometheus配置文件。每次对Prometheus配置文件进行升级时，我们需要手动移除已经运行的Pod实例，从而让Kubernetes可以使用最新的配置文件创建Prometheus。 而如果当应用实例的数量更多时，通过手动的方式部署和升级Prometheus过程繁琐并且效率低下。</p> <p>The Operator encapsulates a large part of the Prometheus domain knowledge and only surfaces aspects meaningful to the monitoring system's end user. It's a powerful approach that enables engineers across all teams of an organization to be autonomous and flexible in the way they run their monitoring.</p> <p>下图是Prometheus Operator架构图</p> <p><img src="http://stiles.cc/assets/img/3859079521.52c40d08.png" alt="../uploads/2020/12/3859079521.png"></p> <p>Operator是核心部分，作为一个控制器而存在，Operator会创建Prometheus、ServiceMonitor、AlertManager及PrometheusRule这4个CRD资源对象，然后一直监控并维持这4个CRD资源对象的状态</p> <ul><li>Prometheus: 声明式创建和管理Prometheus Server实例</li> <li>ServiceMonitor: 负责声明式的管理监控配置,资源对象是专门提供metrics数据接口的exporter的抽象，Prometheus就是通过ServiceMonitor: 提供的metrics数据接口去 pull 数据的</li> <li>AlerManager: 声明式的创建和管理Alertmanager实例</li> <li>PrometheusRule 资源对象是被Prometheus实例使用的告警规则配置</li></ul> <p><strong>3：kubernetes 上部署Prometheus</strong></p> <p>方式1：原生自建 <a href="https://yunlzheng.gitbook.io/prometheus-book/part-iii-prometheus-shi-zhan/readmd/deploy-prometheus-in-kubernetes" target="_blank" rel="noopener noreferrer">点击<span> </span></a>方式2：Prometheus Operator：<a href="https://yunlzheng.gitbook.io/prometheus-book/part-iii-prometheus-shi-zhan/operator/what-is-prometheus-operator" target="_blank" rel="noopener noreferrer">点击<span> </span></a></p> <ul><li>Prometheus Operator 使用CustomResourceDefinition 来自定义资源，而CustomResourceDefinition 需要依赖kubernetes 1.16版本之上具体细节：CustomResourceDefinition 版本：https://kubernetes.io/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/</li></ul> <p><strong>4：Prometheus告警定义</strong></p> <p>告警能力在Prometheus的架构中被划分成两个独立的部分。如下所示，通过在Prometheus中定义AlertRule（告警规则），Prometheus会周期性的对告警规则进行计算，如果满足告警触发条件就会向Alertmanager发送告警信息。</p> <p><img src="http://stiles.cc/assets/img/3027638514.64275318.png" alt="../uploads/2020/12/3027638514.png"></p> <p><strong>4.1.告警规则组成</strong></p> <p>在Prometheus中一条告警规则主要由以下几部分组成：</p> <ul><li>告警名称：用户需要为告警规则命名，当然对于命名而言，需要能够直接表达出该告警的主要内容</li> <li>告警规则：告警规则实际上主要由PromQL进行定义，其实际意义是当表达式（PromQL）查询结果持续多长时间（During）后出发告警</li></ul> <p>一条典型的告警规则如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>groups:
- name: example
  rules:
  - alert: HighErrorRate
    expr: job:request_latency_seconds:mean5m{job="myjob"} &gt; 0.5
    for: 10m
    labels:
      severity: page
    annotations:
      summary: High request latency
      description: description info
</code></pre></div><p>在告警规则文件中，我们可以将一组相关的规则设置定义在一个group下。在每一个group中我们可以定义多个告警规则(rule)。一条告警规则主要由以下几部分组成：</p> <p>alert：告警规则的名称。</p> <p>expr：基于PromQL表达式告警触发条件，用于计算是否有时间序列满足该条件。</p> <p>for：指定Prometheus服务等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为pending。</p> <p>labels：自定义标签，允许用户指定要附加到告警上的一组附加标签，任何已存在的冲突标签都会被重写。</p> <p>annotations：用于指定一组附加信息，比如用于描述告警详细信息的文字等，annotations的内容在告警产生时会一同作为参数发送到Alertmanager。</p> <p><strong>4.2.如何启用告警规则</strong></p> <p>在Prometheus全局配置文件中通过rule_files指定一组告警规则文件的访问路径，Prometheus启动后会自动扫描这些路径下规则文件中定义的内容，并且根据这些规则计算是否向外部发送通知：</p> <div class="language- extra-class"><pre class="language-text"><code>rule_files:
  [ - &lt;filepath_glob&gt; ... ]

#例如：
rule_files:
- /etc/prometheus/rules/*.yml
</code></pre></div><p>默认情况下Prometheus会每分钟对这些告警规则进行计算，如果用户想定义自己的告警计算周期，则可以通过evaluation_interval来覆盖默认的计算周期：</p> <div class="language- extra-class"><pre class="language-text"><code>global:
  [ evaluation_interval: &lt;duration&gt; | default = 1m ]
</code></pre></div><p><strong>4.3.模板化</strong></p> <p>一般来说，在告警规则文件的annotations中使用summary描述告警的概要信息，description用于描述告警的详细信息。同时Alertmanager的UI也会根据这两个标签值，显示告警信息。为了让告警信息具有更好的可读性，Prometheus支持模板化label和annotations中的标签的值。</p> <p>通过$labels.<labelname>变量可以访问当前告警实例中指定标签的值。$value则可以获取当前PromQL表达式计算的样本值</labelname></p> <div class="language- extra-class"><pre class="language-text"><code># To insert a firing element's label values:
{{ $labels.&lt;labelname&gt; }}
# To insert the numeric expression value of the firing element:
{{ $value }}
</code></pre></div><p>例如，可以通过模板化优化summary以及description的内容的可读性：</p> <div class="language- extra-class"><pre class="language-text"><code>groups:
- name: example
  rules:
  # Alert for any instance that is unreachable for &gt;5 minutes.
  - alert: InstanceDown
    expr: up == 0
    for: 5m
    labels:
      severity: page
    annotations:
      summary: "Instance {{ $labels.instance }} down"
      description: "{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes."
  # Alert for any instance that has a median request latency &gt;1s.
  - alert: APIHighRequestLatency
    expr: api_http_request_latencies_second{quantile="0.5"} &gt; 1
    for: 10m
    annotations:
      summary: "High request latency on {{ $labels.instance }}"
      description: "{{ $labels.instance }} has a median request latency above 1s (current value: {{ $value }}s)"
</code></pre></div><p><strong>4.4.警报触发</strong></p> <p>Prometheus以一个固定时间间隔来评估所有规则，这个时间由evaluate_interval定义，我们将其设置为15秒。在每个评估周期，Prometheus运行每个警报规则中定义的表达式并更新警报状态。警报可能有以下三种状态：Inactive：警报未激活。Pending：警报已满足测试表达式条件，但仍在等待for子句中指定的持续时间。Firing：警报已满足测试表达式条件，并且Pending的时间已超过for子句的持续时间。</p> <p>Pending到Firing的转换可以确保警报更有效，且不会来回浮动。没有for子句的警报会自动从Inactive转换为Firing，只需要一个评估周期即可触发。带有for子句的警报将首先转换为Pending，然后转换为Firing，因此至少需要两个评估周期才能触发。</p> <p><strong>5：AlertManager告警管理</strong></p> <p>描述：alertmanager可以接受prometheus报警，由prometheus来定义满足什么条件的发送告警到alertmanager</p> <p><strong>5.1.Alertmanager如何工作?</strong></p> <p>Alertmanager处理从客户端发来的警报，客户端通常是Prometheus服务器如图所示。它还可以接收来自其他工具的警报。Alertmanager对警报进行去重、分组，然后路由到不同的接收器，如电子邮件、短信或SaaS服务（PagerDuty等）。你还可以使用Alertmanager管理维护。</p> <p><img src="http://stiles.cc/assets/img/3034663772.428dc505.png" alt="../uploads/2020/12/3034663772.png"></p> <p><strong>5.2.关联Prometheus与Alertmanager</strong></p> <p>在Prometheus的架构中被划分成两个独立的部分。Prometheus负责产生告警，而Alertmanager负责告警产生后的后续处理。因此Alertmanager部署完成后，需要在Prometheus中设置Alertmanager相关的信息。</p> <p>编辑Prometheus配置文件,并添加以下内容</p> <div class="language- extra-class"><pre class="language-text"><code>alerting:
  alertmanagers:
    - static_configs:
        - targets: ['localhost:9093']
</code></pre></div><p>完成后重启Prometheus服务，通过</p> <p>http://127.0.0.1/status</p> <p>的alertmanagers节点查看是否绑定成功</p> <p><img src="http://stiles.ccdata:image/png;base64,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" alt="../uploads/2020/12/868175763.png"></p> <p><strong>5.3.Alertmanager配置详解</strong></p> <p>Alertmanager主要负责对Prometheus产生的告警进行统一处理，因此在Alertmanager配置中一般会包含以下几个主要部分：</p> <p>全局配置（global）：用于定义一些全局的公共参数，如全局的SMTP配置，Slack配置等内容；模板（templates）：用于定义告警通知时的模板，如HTML模板，邮件模板等；告警路由（route）：根据标签匹配，确定当前告警应该如何处理；接收人（receivers）：接收人是一个抽象的概念，它可以是一个邮箱也可以是微信，Slack或者Webhook等，接收人一般配合告警路由使用；抑制规则（inhibit_rules）：合理设置抑制规则可以减少垃圾告警的产生</p> <p>简单的示例：</p> <div class="language- extra-class"><pre class="language-text"><code>global:
  #在没有报警的情况下声明为已解决的时间
  resolve_timeout: 5m
route:
  #这里的标签列表是接受到告警信息后的重新分组标签，例如,在接收到告警信息里有许多具有cluster=A和alertname=LatncyHigh标签的告警信息会被批量聚合到一个分组里
  group_by: ['alertname','cluster']
  #在一个新的告警分组被创建后，需要等待至少group_wait时间来初始化通知，这种方式可以确保有足够的时间为同一分组获取多条报警，然后一起触发这条告警信息
  group_wait: 30s
  #在第1条告警发送后，等待group_interval时间来发送新的一组告警信息
  group_interval: 2m
  #如果某条告警信息已经发送成功，则等待repeat_interval时间重新发送它们
  repeat_interval: 2m
  #默认的receiver:如果某条告警没有被一条route匹配，则发送给默认的接收器
  receiver: 'webhook'
receivers:
- name: 'webhook'
  webhook_configs:
  - url: '&lt;http://ip&gt;'
    send_resolved: true
</code></pre></div><p>更多细节查看官网：https://prometheus.io/docs/alerting/latest/configuration/</p> <p><strong>6：3大监控方法论</strong></p> <p>1.Google的四大黄金指标</p> <p>2.Netflix的USE方法</p> <p>3.Weave Cloud的RED方法*监控方法提供的指导原则可以让你缩小范围并专注于所收集的海量时间序列中的特定指标。</p> <p><strong>6.1.Google的四大黄金指标</strong></p> <p>有4个来自Google SRE手册的黄金指标，这4个指标主要针对应用程序或用户部分。</p> <p><strong>延迟（Latency）</strong>：服务请求所需耗时，例如HTTP请求平均延迟。需要区分成功请求和失败请求，因为失败请求可能会以非常低的延迟返回错误结果。</p> <p><strong>流量（Traffic）</strong>：衡量服务容量需求（针对系统而言），例如每秒处理的HTTP请求数或者数据库系统的事务数量。</p> <p><strong>错误（Errors）</strong>：请求失败的速率，用于衡量错误发生的情况，例如HTTP 500错误数等显式失败，返回错误内容或无效内容等隐式失败，以及由策略原因导致的失败（比如强制要求响应时间超过30ms的请求为错误）。</p> <p><strong>饱和度（Saturation）</strong>：衡量资源的使用情况，例如内存、CPU、I/O、磁盘使用量（即将饱和的部分，比如正在快速填充的磁盘）。</p> <ul><li>Google专注于应用程序级监控，Google的四个黄金指标: https://sre.google/sre-book/monitoring-distributed-systems</li> <li><strong>6.2.Netflix的USE方法</strong>USE是Utilization（使用率）、Saturation（饱和度）、Error（错误）的首字母组合，是Netflix的内核和性能工程师Brendan Gregg提出的，主要用于分析系统性能问题，可以指导用户快速识别资源瓶颈及错误。</li> <li><strong>使用率</strong>：关注系统资源的使用情况。这里的资源主要包括但不限于CPU、内存、网络、磁盘等。100%的使用率通常是系统性能瓶颈的标志。</li> <li><strong>饱和度</strong>：例如CPU的平均运行排队长度，这里主要是针对资源的饱和度（注意，不同于四大黄金指标）。任何资源在某种程度上的饱和都可能导致系统性能的下降。</li> <li><strong>错误</strong>：错误数。例如，网卡在数据包传输过程中检测到以太网络冲突了14次。</li> <li>USE 侧重于主机级监控,针对每个资源，检查使用率、饱和度和错误。该方法对于监控那些受高使用率或饱和度的性能问题影响的资源来说是最有效的。让我们快速查看每个术语的定义以帮助理解。</li></ul> <p>Linux系统的参考示例清单:<a href="http://www.brendangregg.com/USEmethod/use-linux.html" target="_blank" rel="noopener noreferrer">链接<span> </span></a></p> <p><strong>3.Weave Cloud的RED方法</strong></p> <p>RED方法是Weave Cloud基于Google的4个黄金指标再结合Prometheus及Kubernetes容器实践得出的方法论，特别适用于对云原生应用以及微服务架构应用进行监控和度量。在四大黄金指标的原则下，RED方法可以有效地帮助用户衡量云原生以及微服务应用下的用户体验问题。RED方法主要关注以下3种关键指标。</p> <p><strong>（Request）Rate</strong>：每秒接收的请求数。</p> <p><strong>（Request）Errors</strong>：每秒失败的请求数。</p> <p><strong>（Request）Duration</strong>：每个请求所花费的时间，用时间间隔表示。</p> <p>RED方法:<a href="https://www.weave.works/blog/the-red-method-key-metrics-for-microservices-architecture/" target="_blank" rel="noopener noreferrer">链接<span> </span></a></p> <p>一般来说，上述三大监控理论的最佳实践是：在遵循Google四大黄金指标的前提下，对于在线系统，结合RED方法和缓存命中率方式进行监测；对于离线系统或者主机监控，以USE方法为主进行监测；对于批处理系统，可以采用类似Pushgateway的形式进行监控。</p> <p><strong>参考链接</strong></p> <p>prometheus-book：<a href="https://yunlzheng.gitbook.io/prometheus-book/" target="_blank" rel="noopener noreferrer">https://yunlzheng.gitbook.io/prometheus-book<span> </span></a></p> <p>Prometheus官网：<a href="https://prometheus.io/" target="_blank" rel="noopener noreferrer">https://prometheus.io<span> </span></a></p> <p>Prometheus文档：<a href="https://prometheus.io/docs/" target="_blank" rel="noopener noreferrer">https://prometheus.io/docs<span> </span></a></p> <p>Prometheus云原生监控：运维与开发实战：<a href="https://read.douban.com/ebook/162985878/" target="_blank" rel="noopener noreferrer">https://read.douban.com/ebook/162985878<span> </span></a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SqlServer上亿数据迁移到redis]]></title>
            <link>http://stiles.cc/docs/engineering/SqlServer%E4%B8%8A%E4%BA%BF%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E5%88%B0redis.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/engineering/SqlServer%E4%B8%8A%E4%BA%BF%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E5%88%B0redis.html</guid>
            <pubDate>Mon, 09 Nov 2020 07:54:08 GMT</pubDate>
            <content:encoded><![CDATA[ <p>记录下工作上最近遇到的一次sqlserver数据迁移到redis上面的一些经验</p> <p>方案一:redis2.6之后使用redis-cli支持pipe模式进行批量插入数据生成file.txt 文件，内容 SET key value（空格隔开）每行一条数据linux环境下使用-cat命令</p> <div class="language- extra-class"><pre class="language-text"><code>cat file.txt | D:\\redis\\redis-cli -h 192.168.1.x -a password -p 6379 --pipe
</code></pre></div><p>windows 环境下使用-type命令</p> <div class="language- extra-class"><pre class="language-text"><code>type file.txt | D:\\redis\\redis-cli -h 192.168.1.x -a password -p 6379 --pipe
</code></pre></div><p>方案二:使用sqlcmd（sql自带）管道导入到redis-cli这里稍微解释一下sqlcmd命令行参数：-S：服务器-U：用户名-P：密码-d：数据库名称-h：当为-1时，运行结果中不输出字段名称-i：要运行sql文件file.sql文件查询格式类似如下</p> <div class="language- extra-class"><pre class="language-text"><code>select concat('set ','key',' value')
</code></pre></div><p>sqlcmd示例如下:</p> <div class="language- extra-class"><pre class="language-text"><code>sqlcmd -S 192.168.1.x -U sql_username -P sql_password -d
database -h -1 -i C:\\Users\\Administrator\\Desktop\\file.sql | D:\\redis\\redis-cli -h
192.168.1.x -a redis_password -p 6379
</code></pre></div><p>方案三:自写工具实现迁移...</p> <p>总结：</p> <p>1.方案1和比方案二效率要高些，不过需要生成确定格式的file文件</p> <p>2.在实际操作中方案二在数据量较大的情况下，在跑到300多万数据的时候经常会发生异常中断的情况</p> <p>3.通过自写个程序批量处理批量插入数据是比较合适的方式而且后期可以复用，性能也有保障</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[mongodb-入门到使用]]></title>
            <link>http://stiles.cc/docs/java/mongodb-%E5%85%A5%E9%97%A8%E5%88%B0%E4%BD%BF%E7%94%A8.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/java/mongodb-%E5%85%A5%E9%97%A8%E5%88%B0%E4%BD%BF%E7%94%A8.html</guid>
            <pubDate>Thu, 29 Oct 2020 11:11:00 GMT</pubDate>
            <content:encoded><![CDATA[ <p><strong>1.什么是mongodb</strong></p> <p>MongoDB是一个高性能、开源、无模式的文档型数据库，使用C++开发，是当前NoSQL数据库产品中最热门的一种。在许多场景下，它可以替代传统的关系型数据库或键-值存储方式.</p> <p>Mongodb从3.0开始默认使用的是WiredTiger引擎数据库排名：DB-Engines：https://db-engines.com/en/ranking</p> <p><img src="http://stiles.cc/assets/img/2091438569.1265c939.jpg" alt="../uploads/2020/10/2091438569.jpg"></p> <p><strong>文档形数据库特点</strong></p> <p>1:满足了海量数据的存储和访问需求</p> <p>2:字段要求不严格，可以随意地增加、删除、修改字段，且不需要预先定义表结构*按照官方文档记载，当数据量达到50GB以上时，MongoDB的数据库访问速度是MySQL的10倍以上。</p> <p>MongoDB快的原因是:</p> <p>1: MongoDB的设计要求你常用的数据（working set)可以在内存里装下。这样大部分操作只需要读内存，自然很快。</p> <p>2: 文档性模式设计一般会是你所需要的数据都相对集中在一起（内存或硬盘），大家知道硬盘读写耗时最多是随机读写所产生的磁头定位时间，数据集中在一起则减少了关系性数据库需要从各个地方去把数据找过来（然后Join）所耗费的随机读时间</p> <p>3: 可以平行扩展。目前一般的百万次并发量都是通过几十上百个节点的集群同时实现。这一点MySQL基本无法做到（或者要花很大定制的代价）</p> <p>写操作MongoDB比传统数据库快的根本原因是Mongo使用的内存映射技术写入数据时候只要在内存里完成就可以返回给应用程序，这样并发量自然就很高。而保存到硬体的操作则在后台异步完成。</p> <p><strong>适用场景</strong></p> <p>1.对数据库高并发读写的需求</p> <p>2.对海量数据的高效率存储和访问的需求</p> <p>3.对数据库的高可扩展性和高可用性的需求</p> <p><strong>和传统数据库简单对比</strong></p> <p>非结构型数据库。没有行和列的概念，用Json(Bson)来存储数据</p> <p><strong>Nosql(Not Only SQL)兴起</strong></p> <p>由于关系型数据库的范式约束、事务特性、磁盘 IO 等特点，若服务器使用关系型数据库，当有大量数据产生时，传统的关系型数据库已经无法满足快速查询与插入数据的需求。NoSQL 的出现解决了这一危机。它通过降低数据的安全性，减少对事务的支持，减少对复杂查询的支持，获取性能上的提升</p> <table><thead><tr><th>Nosql</th> <th>RDBMS</th></tr></thead> <tbody><tr><td>没有声明式查询语句</td> <td>高度组织化结构化数据</td></tr> <tr><td>没有预定义的模式</td> <td>结构化查询语言（SQL）</td></tr> <tr><td>健-值对存储，列存储，文档存储，图形存储</td> <td>数据和关系都存储在单独的表中</td></tr> <tr><td>最终一致性，而非ACID属性</td> <td>数据操作语言，数据定义语言</td></tr> <tr><td>非结构化和不可预知的数据</td> <td>严格的一致性</td></tr> <tr><td>CAP定理</td> <td>基础事务</td></tr> <tr><td>高性能，高可用性和可伸缩性</td> <td></td></tr></tbody></table> <p>MongoDB的文档相当于关系数据库中的一条记录。多个文档组成一个集合，相当于关系数据库的表。多个集合逻辑上组织在一起就是数据库。一个MongoDB实例支持多个数据库。</p> <p><img src="http://stiles.cc/assets/img/2563475560.db4c8613.jpg" alt="../uploads/2020/10/2563475560.jpg"></p> <table><thead><tr><th>关系型数据库</th> <th>Mongodb</th></tr></thead> <tbody><tr><td>数据库（database）</td> <td>数据库（database）</td></tr> <tr><td>表（table）</td> <td>集合（collection）</td></tr> <tr><td>行（row）</td> <td>document or BSON document（文档）</td></tr> <tr><td>column（列）</td> <td>field（字段）</td></tr> <tr><td>index（索引）</td> <td>index（索引）</td></tr> <tr><td>table joins（表连接）</td> <td>embedded documents and linking（嵌入的文档和链接）</td></tr> <tr><td>primary key Specify any unique column or column combination as primary key.（指定任意唯一的列或列组合作为主键）</td> <td>primary keyIn MongoDB, the primary key isautomatically set to the _id field.（在 MongoDB 中，主键被自动设置为 _id 字段）</td></tr> <tr><td>aggregation (e.g. group by)</td> <td>MongoDB provides three ways to perform aggregation: the aggregation pipeline, the map-reduce function, and single purpose aggregation methods.（聚合操作）</td></tr></tbody></table> <p>文档是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行，但更具表现力。集合（collection）可以看作是一个拥有动态模式（dynamic schema）的表。数据库（database），每一个数据库都拥有自己的集合。</p> <p><strong>mongodb基本数据类型</strong></p> <table><thead><tr><th>数据类型</th> <th>Mongodb</th></tr></thead> <tbody><tr><td>String</td> <td>字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td></tr> <tr><td>Integer</td> <td>整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td></tr> <tr><td>Boolean</td> <td>布尔值。用于存储布尔值（真/假）。</td></tr> <tr><td>Double</td> <td>将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td></tr> <tr><td>Min/Max keys</td> <td>布尔值。用于存储布尔值（真/假）。</td></tr> <tr><td>Arrays</td> <td>用于将数组或列表或多个值存储为一个键。</td></tr> <tr><td>Timestamp</td> <td>时间戳。记录文档修改或添加的具体时间。</td></tr> <tr><td>Object</td> <td>用于内嵌文档。</td></tr> <tr><td>Null</td> <td>用于创建空值。</td></tr> <tr><td>Symbol</td> <td>符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td></tr> <tr><td>Date</td> <td>日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td></tr> <tr><td>Object ID</td> <td>对象 ID。用于创建文档的 ID。</td></tr> <tr><td>Binary Data</td> <td>二进制数据。用于存储二进制数据。</td></tr> <tr><td>Code</td> <td>代码类型。用于在文档中存储 JavaScript 代码。</td></tr> <tr><td>Regular expression</td> <td>正则表达式类型。用于存储正则表达式。</td></tr></tbody></table> <ul><li>每一个文档都有一个特殊的键"_id"，这个键在文档所属的集合中是唯一的。数据库最终会变成文件系统里的文件,而数据库名就是相应的文件名</li></ul> <p><strong>2: 基本命令（CRUD）插入操作</strong></p> <div class="language- extra-class"><pre class="language-text"><code>db.collection.insertOne()
db.collection.insertMany()
</code></pre></div><p><img src="http://stiles.cc/assets/img/3149265186.7c9b4258.jpg" alt="../uploads/2020/10/3149265186.jpg"></p> <p><strong>读取操作</strong></p> <p>db.collection.find()</p> <p>你可以指定查询过滤器或条件来标识要返回的文档</p> <p><img src="http://stiles.cc/assets/img/1465583094.53fb0383.jpg" alt="../uploads/2020/10/1465583094.jpg"></p> <p><strong>更新操作</strong></p> <div class="language- extra-class"><pre class="language-text"><code>db.collection.updateOne()
db.collection.updateMany()
db.collection.replaceOne()
</code></pre></div><p>你可以指定查询过滤器或条件来标识要更新的文档，这里的 过滤器和读操作的语法是一致的。</p> <p><img src="http://stiles.cc/assets/img/1852594781.262bd13a.jpg" alt="../uploads/2020/10/1852594781.jpg"></p> <p><strong>删除操作</strong></p> <div class="language- extra-class"><pre class="language-text"><code>db.collection.deleteOne()
db.collection.deleteMany()
</code></pre></div><p>你可以指定查询过滤器或条件来标识要删除的文档，这里的过滤器和读操作的语法是一致的。</p> <p><img src="http://stiles.cc/assets/img/2931337793.91f92bac.jpg" alt="../uploads/2020/10/2931337793.jpg"></p> <p>其它命令（MongoDB中文手册|官方文档中文版）：</p> <p>https://docs.mongoing.com/</p> <p>聚合管道(Aggregation Pipeline)</p> <p>用来对集合中的文档进行变换和组合。</p> <p><img src="http://stiles.cc/assets/img/2160950145.b755b3ff.jpg" alt="../uploads/2020/10/2160950145.jpg"></p> <p><strong>管道操作符</strong></p> <table><thead><tr><th>管道操作符</th> <th>Description</th></tr></thead> <tbody><tr><td>$project</td> <td>增加,删除,重命名字段</td></tr> <tr><td>$match</td> <td>条件匹配。只满足条件的文档才能进入下一阶段</td></tr> <tr><td>$limit</td> <td>限制结果的数量</td></tr> <tr><td>$skip</td> <td>跳过文档的数量</td></tr> <tr><td>$sort</td> <td>条件排序</td></tr> <tr><td>$group</td> <td>条件组合结果</td></tr> <tr><td>$lookup</td> <td>$lookup操作符 用以引入其他集合的数据</td></tr></tbody></table> <p><strong>SQL和Mongodb对比</strong></p> <table><thead><tr><th>WHERE</th> <th>$match</th></tr></thead> <tbody><tr><td>GROUP BY</td> <td>$group</td></tr> <tr><td>HAVING</td> <td>$match</td></tr> <tr><td>SELECT</td> <td>$project</td></tr> <tr><td>ORDER BY</td> <td>$sort</td></tr> <tr><td>LIMIT</td> <td>$limit</td></tr> <tr><td>SUM()</td> <td>$sum</td></tr> <tr><td>COUNT()</td> <td>$count</td></tr> <tr><td>JOIN</td> <td>$lookup</td></tr></tbody></table> <p><strong>3: 索引</strong></p> <p>索引就相当于字典的目录，先从目录上找到对应查询内容的具体位置，不需要翻遍整本书，就可以直接跳转到目标文档的位置，提高查询的速度。</p> <ul><li>MongoDB索引默认创建的是B树索引为啥mongodb是B树，而mysql选择B+树：https://zhuanlan.zhihu.com/p/102628897</li></ul> <p><strong>单字段索引</strong></p> <p>这里的keyname表示键名；-1:表示索引值按降序排列；1 :表示索引值按升序排列；创建单列唯一索引使用以下语法：</p> <div class="language- extra-class"><pre class="language-text"><code>db.collection.createIndex( { keyname : -1 } )
db.collection.createIndex( {keyname : -1},{"unique" : true})
</code></pre></div><p><strong>复合索引</strong></p> <p>复合索引是Single Field Index的升级版本，它针对多个字段联合创建索引，先按第一个字段排序，第一个字段相同的文档按第二个字段排序，依次类推，如下针对age, name这2个字段创建一个复合索引。</p> <div class="language- extra-class"><pre class="language-text"><code>db.collection.createIndex( { &lt;field1&gt;:&lt;type&gt;,&lt;field2&gt;:&lt;type&gt; , ......} )
db.user.createIndex( { name : -1 , age : -1 } )
</code></pre></div><p>例如，集合test，记录如下：</p> <p><strong>多key索引</strong></p> <p>为了索引包含数组值的字段，MongoDB为数组中的每个元素创建一个索引键。</p> <div class="language- extra-class"><pre class="language-text"><code>{
    "_id" : ObjectId("5f9a617e09e11b41c8ef0943"),
    "name" : "小张",
    "age" : 10.0,
    "description" : "知识分享5",
    "skill" : [
        "java",
        "c#",
        "python"
    ]
}
db.person.createIndex( {skill: 1} )  // 自动创建多key索引
db.person.find( {skill: "java"} )
</code></pre></div><p>文本(全文)索引MongoDB提供全文索引支持文本搜索查询字符串内容。全文索引可以是其值为字符串或字符串元素的数组的字段。目前，MongoDB集合最多只支持一个全文索引。</p> <div class="language- extra-class"><pre class="language-text"><code>db.collection.createIndex( { &lt;fields&gt;:"text" } )
db.collection.createIndex( { &lt;fields1&gt;:"text",&lt;fields2&gt;:"text",......} )
</code></pre></div><p>MongoDB的索引几乎与传统的关系型数据库一模一样索引实际就是对指定字段进行排序的数据结构基于B-Tree的结构提升查询速度。（时间复杂度logn）复合键索引可以对多个字段进行排序。复合键索引只能支持前缀子查询</p> <p><strong>4.MongoDB的事务、ACID和一致性事务</strong></p> <p>事务是指由一系列数据库操作组成的一个完整的逻辑过程，这个过程中的所有操作要么都成功，要么都不成功。比如：常见的例子就是银行转账的例子，一次转账操作会包含多个数据库操作，而这些数据库操作需要放到一个事务当中，保证其要么都成功，要么都不成功。</p> <p><strong>ACID</strong></p> <p>ACID是事务的四个特性，指的是atomicity，原子性；consistency，一致性；isolation，隔离性；durability，持久性。</p> <ol><li>原子性(atomicity): 指所有在事务中的操作要么都成功，要么都不成功，所有的操作都不可分割，没有中间状态。一旦某一步执行失败，就会全部回滚到初始状态。</li> <li>一致性(consistency): 指的是逻辑上的一致性，即所有操作是符合现实当中的期望的。具体参考下一节</li> <li>隔离性(isolation): 即不同事务之间的相互影响和隔离的程度。比如，不同的隔离级别，事务的并发程度也不同，最强的隔离状态是所有的事务都是串行化的（serializable）（即一个事务完成之后才能进行下一个事务），这样并发性也会降到最低，在保证了强一致性的情况下，性能也会受很大影响，所以在实际工程当中，往往会折中一下。</li> <li>持久性(durability): 可以简单地理解为事务执行完毕后数据不可逆并持久化存储于存储系统当中</li></ol> <p><strong>理解一致性</strong></p> <p>实际上我们通常说的数据库事务的一致性和分布式系统的一致性并不是一个概念。这里可以区分成“内部一致性”和“外部一致性”。“内部一致性”搞数据库的人很少这么说，一般就直接说一致性，更准确的说是“Consistency in ACID”（“事务 ACID 属性中的一致性”）；“外部一致性”是针对分布式系统而言的，分布式领域提及的 Consistency 表示系统的正确性模型，著名的 CAP 理论中的 C 就是这个范畴的。这主要是由于分布式系统写入和读取都可能不在同一台机器上，而这必然会有一段时间导致不同机器上所存的数据不一致的情况，这就是所谓的“不一致时间窗口”。</p> <p><strong>CAP</strong></p> <p>CAP理论主要是针对分布式存储系统的，</p> <p>Consistency一致性:是指对于每一次读操作，要么都能够读到最新写入的数据，要么错误。</p> <p>Availability可用性:是指对于每一次请求，都能够得到一个及时的、非错的响应，但是不保证请求的结果是基于最新写入的数据。</p> <p>Partition tolerance分区容忍性:是指由于节点之间的网络问题，即使一些消息对包或者延迟，整个系统能继续提供服务（提供一致性或者可用性）。</p> <p>CAP定理认为分布式系统中这三个特性最多只能同时满足两个特性。下面我们来分别看下这三个特性究竟是什么意思。http://www.ruanyifeng.com/blog/2018/07/cap.html</p> <p><strong>mongodb架构模式</strong></p> <p>Replica set：复制集，mongodb的架构方式之一 ，通常是三个对等的节点构成一个“复制集”集群，有“primary”和secondary等多中角色，其中primary负责读写请求，secondary可以负责读请求，这有配置决定，其中secondary紧跟primary并应用write操作；如果primay失效，则集群进行“多数派”选举，选举出新的primary，即failover机制，即HA架构。复制集解决了单点故障问题，也是mongodb垂直扩展的最小部署单位，当然sharding cluster中每个shard节点也可以使用Replica set提高数据可用性。</p> <p><img src="http://stiles.ccdata:image/jpeg;base64,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" alt="../uploads/2020/10/3406002782.jpg"></p> <p>Sharding cluster：分片集群，数据水平扩展的手段之一；replica set这种架构的缺点就是“集群数据容量”受限于单个节点的磁盘大小，如果数据量不断增加，对它进行扩容将时非常苦难的事情，所以我们需要采用Sharding模式来解决这个问题。将整个collection的数据将根据sharding key被sharding到多个mongod节点上，即每个节点持有collection的一部分数据，这个集群持有全部数据，原则上sharding可以支撑数TB的数据。</p> <p><img src="http://stiles.cc/assets/img/3527651047.4d525deb.jpg" alt="../uploads/2020/10/3527651047.jpg"></p> <p><strong>5.客户端工具安装Studio 3T</strong></p> <p>下载地址：</p> <p>https://robomongo.org/</p> <p>怎么使用：</p> <p>https://mp.weixin.qq.com/s/gk1Bbydz4EY_1x4PpEbIXA</p> <ul><li>以上内容采集于网络由个人汇总整理,如有侵权请告知后及时删除.转载：请注明出处 http://stiles.cc/archives/127/</li></ul> <p><strong>参考资料</strong>https://docs.mongoing.com/https://cloud.tencent.com/developer/article/1710629</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Redis详解]]></title>
            <link>http://stiles.cc/docs/java/Redis%E8%AF%A6%E8%A7%A3.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/java/Redis%E8%AF%A6%E8%A7%A3.html</guid>
            <pubDate>Thu, 01 Oct 2020 12:54:00 GMT</pubDate>
            <content:encoded><![CDATA[ <p><strong>Redis (Remote Dictionary Server) 即远程字典服务.</strong></p> <p>是一个开源的使用 ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、<strong>key-value 数据库</strong>，并提供多种语言的 API。是当下最热门的NoSQL 技术之一，也被人们称之为机构化数据库。</p> <p><strong>redis高性能的设计体现</strong></p> <p>据说: QPS: 100000+（每秒内查询次数）</p> <p>1.完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。它的，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p> <p>2.数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p> <p>3.采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p> <p>4.使用多路I/O复用模型，非阻塞IO；</p> <p>5.使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p> <p><img src="http://stiles.cc/assets/img/1011510264.cc2b4194.png" alt="../uploads/2020/10/1011510264.png"></p> <p><strong>数据类型</strong></p> <p>String：字符串List（列表）: 用作栈、队列、阻塞队列。Hash(哈希)：也是 key - value 形式的，但是value 是一个map。Set（集合）ZSet(排序集合)HeperloglogBitmap（位图）Geo (地图坐标)Stream(流)</p> <p><strong>持久化</strong></p> <p>1.RDB：默认持久化机制，是对 Redis 中的数据执行周期性的持久化。2.AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快。3.RDB-AOF混合持久化</p> <p><strong>1.RDB (Save指令)</strong></p> <p>1.创建新的RDB文件</p> <p>2.遍历数据库包含的所有数据库，并将各个数据库包含的键值对全部记录到RDB文件中</p> <p>3.代替已有的RDB文件</p> <p><img src="http://stiles.cc/assets/img/2319088342.7c473411.png" alt="../uploads/2020/10/2319088342.png"></p> <p>**2.RDB (BGSave)**1.创建子进程2.子进程执行SAVE命令，创建新的RDB文件.3.RDB文件创建完毕之后，子进程退出并通知Redis服务器进程（父进程）新RDB文件已经完成4.Redis服务器进程使用新RDB文件替换已有的RDB文件</p> <p><strong>RDB相关配置</strong></p> <div class="language- extra-class"><pre class="language-text"><code>save 900 1   #保存数据到硬盘 ，如果 900s 内，至少有 1 个 key 进行了修改，进行持久化操作
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes  # 如果持久化出错，是否还要继续工作
rdbcompression yes    # 是否压缩 rdb 文件，需要消耗一些 cpu 资源
rdbchecksum yes # 保存 rdb 文件的时候，进行错误的检查校验
dir ./  # rdb 文件保存的目录
dbfilename dump.rdb # 存储rdb文件的文件名
</code></pre></div><p><strong>RDB触发机制</strong>1.save 的规则满足的情况下，会自动触发 rdb 规则2.执行 flushall 命令，也会触发 rdb 规则3.退出 redis 也会产生 rdb 文件</p> <p><strong>RDB优缺点</strong>优点：1.适合大规模的数据恢复2.对数据的完整性要求不高缺点：1.需要一定的时间间隔进行操作，如果 Redis 意外宕机，最后一次修改的数据就没有了2.fork 进程的时候，会占用一定的空间。</p> <p>**2.AOF (Append Only File)**AOF提供的是增量式的持久化功能,以日志形式来记录每个操作，将 Redis 执行的过程的所有指令记录下来（读操作不记录），只追加文件但不可以改写文件，redis 启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一遍以完成数据的恢复工作。<strong>AOF相关配置</strong></p> <div class="language- extra-class"><pre class="language-text"><code>appendonly yes   #默认是no
appendfilename “appendonly.aof”
#AOF文件的冲洗频率
appendsync everysec 每秒执行一次sync,可能会丢失这一秒的数据
#appendsync always  每次修改都会sync,消耗性能
#appendsync no   不执行fsync调度,这个时候操作系统自己同步数据，速度最快
auto-aof-rewrite-percentage  100
auto-aof-rewrite-min-size 64mb
BGREWRITEAOF  触发aof重写
</code></pre></div><p><strong>AOF优缺点</strong>优点：通过使用everysec选项，用户可以将数据丢失的时间窗口限制在1s之内缺点：因为AOF文件存储的是协议文本，所以它的体积会比包含相同数据、二进制格式的RDB文件要大得多,修复速度也比rdb慢</p> <p><strong>3.RDB-AOF混合持久化</strong></p> <p>Redis4.0版本开始引入</p> <p>配置aof-use-rdb-preamble yes开启</p> <p>选项的值设置成了yes，那么Redis服务器在执行AOF重写操作时，就会像执行BGSAVE命令那样，根据数据库当前的状态生成出相应的RDB数据，并将这些数据写入新建的AOF文件中，至于那些在AOF重写开始之后执行的Redis命令，则会继续以协议文本的方式追加到新AOF文件的末尾，即已有的RDB数据的后面。</p> <p><img src="http://stiles.cc/assets/img/2322727788.f5fb5b48.png" alt="../uploads/2020/10/2322727788.png"></p> <p><strong>内存回收机制</strong></p> <p>1.Key过期删除策略</p> <p>2.内存使用到达maxmemory上限时触发内存溢出控制策略</p> <p>先说下<strong>过期删除策略</strong></p> <p>1.<strong>定时删除</strong>:在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</p> <p>2.<strong>惰性删除</strong>: 放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</p> <p>3.<strong>定期删除</strong>:每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。在这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略。</p> <p><strong>redis采用了惰性删除和定期删除策略</strong>[参考](http://stiles.cc/archives/92/在这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略。 https://www.cnblogs.com/capacity-yang/p/13095005.html)</p> <p><strong>惰性删除策略的实现</strong></p> <p>过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：</p> <p>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除。</p> <p>如果输入键未过期，那么expireIfNeeded函数不做动作。</p> <p><img src="http://stiles.cc/assets/img/1219281060.4fcbca01.png" alt="../uploads/2020/10/1219281060.png"></p> <p><strong>定期删除</strong></p> <p>Redis内部维护一个定时任务，默认每秒运行10次。定时任务中删除过期键逻辑采用了自适应算法，根据键的过期比例，使用快慢两种速率回收键，流程如下图</p> <p><img src="http://stiles.cc/assets/img/2625828272.b650c423.png" alt="../uploads/2020/10/2625828272.png"></p> <p><strong>流程说明</strong></p> <p>1.定时任务在每个数据库空间随机检查20个键，当发现过期时删除对应的键</p> <p>2.如果超过检查数的25%的键过期，循环执行回收逻辑直到不足25%或运行超时为止，慢模式下超时时间为25毫秒</p> <p>3.如果之前回收键逻辑超时，则在Redis触发内部事件之前再次以快模式运行回收过期键任务，快模式下超时时间为1毫秒且2秒内只能运行1次</p> <p>4.快慢两种模式内部删除逻辑相同，只是执行的超时时间不同。</p> <p><strong>内存淘汰机制</strong></p> <p>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</p> <p>allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</p> <p>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</p> <p>allkeys-random: 回收随机的键使得新添加的数据有空间存放。</p> <p>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</p> <p>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</p> <p>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p> <p>volatile为前缀的策略都是从已过期的数据集中进行淘汰。allkeys为前缀的策略都是面向所有key进行淘汰。LRU（least recently used）最近最少用到的。LFU（Least Frequently Used）最不常用的。它们的触发条件都是Redis使用的内存达到阈值时。</p> <p><strong>Redis部署</strong></p> <p>1.主从复制</p> <p>2.Sentinel（哨岗、哨兵）是Redis的高可用性解决方案</p> <p>3.cluster</p> <p><strong>1.主从复制(master-slave replication)</strong></p> <p>主从模式是三种模式中最简单的，在主从复制中，数据库分为两类：主数据库(master)和从数据库(slave)。
以下指令设置服务器为主服务器到从服务器replicaof host portredis-server - -port 6380 - -replicaof 127.0.0.1 6379</p> <p>当一个从数据库启动后，会向主数据库发送SYNC命令，主数据库接收到SYNC命令后会开始在后台保存快照（即RDB持久化的过程），并将保存期间接收到的命令缓存起来。当快照完成后，Redis会将快照文件和所有缓存的命令发送给从数据库。从数据库收到后，会载入快照文件并执行收到的缓存的命令。当主从数据库断开重连后会重新执行上述操作，不支持断点续传。</p> <p><strong>主从复制到完整同步操作</strong></p> <p>主服务器执行BGSAVE命令，生成一个RDB文件，并使用缓冲区存储起在BGSAVE命令之后执行的所有写命令。当RDB文件创建完毕，主服务器会通过套接字将RDB文件传送给从服务器。从服务器在接收完主服务器传送过来的RDB文件之后，就会载入这个RDB文件，从而获得主服务器在执行BGSAVE命令时的所有数据。当从服务器完成RDB文件载入操作，并开始上线接受命令请求时，主服务器就会把之前存储在缓存区中的所有写命令发送给从服务器执行。</p> <ol><li><p>每当主服务器执行完一个写命令之后，它就会将相同的写命令或者具有相同效果的写命令发送给从服务器执行。</p></li> <li><p>因为完整同步之后的主从服务器在执行最新出现的写命令之前，两者的数据库是完全相同的，而导致两者数据库出现不一致的正是最新被执行的写命令，因此从服务器只要接收并执行主服务器发来的写命令，就可以让自己的数据库重新与主服务器数据库保持一致。</p></li></ol> <p><strong>部分同步操作</strong></p> <p>当一个Redis服务器成为另一个服务器的主服务器时，它会把每个被执行的写命令都记录到一个特定长度的先进先出队列中。当断线的从服务器尝试重新连接主服务器的时候，主服务器将检查从服务器断线期间，被执行的那些写命令是否仍然保存在队列里面。如果是，那么主服务器就会直接把从服务器缺失的那些写命令发送给从服务器执行，从服务器通过执行这些写命令就可以重新与主服务器保持一致，这样就避免了重新进行完整同步的麻烦。如果从服务器缺失的那些写命令已经不存在于队列当中，那么主从服务器将进行一次完整同步。</p> <p><strong>主从复制的优点:</strong></p> <p>在性能方面，Redis的复制功能可以给系统的读性能带来线性级别的提升.从理论上来说，用户每增加一倍数量的从服务器，整个系统的读性能就会提升一倍。其次，通过增加从服务器的数量，用户可以降低系统在遭遇灾难故障时丢失数据的可能性。最后，通过同时使用Redis的复制功能和Sentinel功能，用户可以为整个Redis系统提供高可用特性</p> <p><strong>2.Sentinel(哨兵)</strong></p> <p>启动哨兵命令: redis-sentinel /etc/sentinel.conf
内容如下: sentinel monitor选项中的master-name参数用于指定主服务器的名字，这个名字在执行各种Sentinel操作的时候会经常用到；ip参数和port参数用于指定主服务器的IP地址和端口号；而quorum参数则用于指定判断这个主服务器下线所需的Sentinel数量。</p> <p><img src="http://stiles.cc/assets/img/4053313826.5ce8f26b.png" alt="../uploads/2020/10/4053313826.png"></p> <p>例如:sentinel monitor test_db 127.0.0.1 16379 1</p> <p>步骤</p> <p>1.双环图形是当前的主服务器server1。</p> <p>2.用单环图案表示的是主服务器的三个从服务器server2、server3以及server4。</p> <p>3.server2、server3、server4三个从服务器正在复制主服务器server1，而Sentinel系统则在监视所有四个服务器</p> <p><img src="http://stiles.cc/assets/img/1312386298.351b191d.png" alt="../uploads/2020/10/1312386298.png"></p> <p>假设主服务器server1进入下线状态</p> <p>下线时长超过用户设置时长上限,执行故障转移操作</p> <p>1.Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器。</p> <p>2.Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。</p> <p>3.Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器。</p> <p><img src="http://stiles.cc/assets/img/3581001168.6581210c.png" alt="../uploads/2020/10/3581001168.png"></p> <p><img src="http://stiles.cc/assets/img/638730826.37de643e.png" alt="../uploads/2020/10/638730826.png"></p> <p><img src="http://stiles.cc/assets/img/2071455166.33625c7c.png" alt="../uploads/2020/10/2071455166.png"></p> <p>Sentinel(哨兵)细节</p> <p>1.由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p> <p>2.普通服务器在初始化时会通过载入RDB文件或者AOF文件来还原数据库状态，但是因为Sentinel并不使用数据库，所以初始化Sentinel时就不会载入RDB文件或者AOF文件</p> <p>3.使用 REDIS_SENTINEL_PORT 26379 为服务器端口</p> <p><strong>3.Redis集群</strong></p> <p>Redis提供的分布式数据库方案,集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。</p> <p>Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接1.配置文件cluster-enable yes 开启集群节点</p> <p>2.cluster meet ip port 添加入集群</p> <p><img src="http://stiles.cc/assets/img/1305946259.a5ce0618.png" alt="../uploads/2020/10/1305946259.png"></p> <p>集群的特点</p> <p>1.所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。</p> <p>2.节点的fail是通过集群中超过半数的节点检测失效时才生效。</p> <p>3.客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用即可。</p> <p><strong>分片</strong></p> <p>1.与单机版Redis将整个数据库放在同一台服务器上的做法不同，Redis集群通过将数据库分散存储到多个节点上来平衡各个节点的负载压力。</p> <p>2.Redis集群会将整个数据库空间划分为16384个槽（slot）来实现数据分片（sharding），而集群中的各个主节点则会分别负责处理其中的一部分槽。当用户尝试将一个键存储到集群中时，客户端会先计算出键所属的槽，接着在记录集群节点槽分布的映射表中找出处理该槽的节点，最后再将键存储到相应的节点中</p> <p><strong>槽</strong></p> <p>Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。</p> <p><img src="http://stiles.cc/assets/img/4143061613.a3653a74.png" alt="../uploads/2020/10/4143061613.png"></p> <p><strong>主节点和从节点</strong></p> <p>Redis集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。</p> <p>命令转向</p> <p><img src="http://stiles.cc/assets/img/2896598628.21b09bcd.png" alt="../uploads/2020/10/2896598628.png"></p> <p><img src="http://stiles.cc/assets/img/575221201.2a6e9390.png" alt="../uploads/2020/10/575221201.png"></p> <p><strong>为何集群高性能</strong></p> <p>Redis集群采用无代理模式，客户端发送的所有命令都会直接交由节点执行，并且对于经过优化的集群客户端来说，客户端发送的命令在绝大部分情况下都不需要实施转向，或者仅需要一次转向，因此在Redis集群中执行命令的性能与在单机Redis服务器上执行命令的性能非常接近。除了节点之间互通信息带来的性能损耗之外，单个Redis集群节点处理命令请求的性能与单个Redis服务器处理命令请求的性能几乎别无二致。从理论上来讲，集群每增加一倍数量的主节点，集群对于命令请求的处理性能就会提高一倍。</p> <p><strong>参考资料</strong></p> <p>https://blog.itzhouq.cn/redis1<a href="https://e.jd.com/30189715.html" target="_blank" rel="noopener noreferrer">redis设计与实践<span> </span></a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ELK监控搭建]]></title>
            <link>http://stiles.cc/docs/engineering/ELK%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/engineering/ELK%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA.html</guid>
            <pubDate>Sat, 06 Jun 2020 01:32:08 GMT</pubDate>
            <content:encoded><![CDATA[ <p>实现Elasticsearch监控报警，x-pack,Sentinl,Watcher 等都是可行性方案之一,如下记下最近搭建的心得</p> <p>使用x-pack 监控</p> <p>1：安装x-pack: Elasticsearch安装目录下执行 bin/elasticsearch-plugin install x-pack（基本上都是安装失败，本来x-pack文件很大，同时又被墙）</p> <p>2：本地安装：https://artifacts.elastic.co/downloads/packs/x-pack/x-pack-6.2.4.zip</p> <p>下载对应文件后执行 bin/elasticsearch-plugin install file:///path/to/file/x-pack-6.2.4.zip</p> <p>具体参考：</p> <p>https://www.elastic.co/guide/en/elasticsearch/reference/6.2/installing-xpack-es.html</p> <p><img src="http://stiles.cc/assets/img/1059343506.e36af663.png" alt="../uploads/2020/10/1059343506.png"></p> <p>更改 elasticsearch 的密码执行bin/x-pack/setup-passwords interactive 然后回车设置密码。</p> <p>其他节点只要安装了x-pack插件的话，就可以直接加入了，无需再设置密码了。</p> <div class="language- extra-class"><pre class="language-text"><code>#修改密码的方式
curl -H "Content-Type:application/json" -XPOST -u elastic '&lt;http://127.0.0.1:9200/_xpack/security/user/elastic/_password&gt;' -d '{ "password" : "changme" }'
</code></pre></div><p>config/elasticsearch.yml添加</p> <div class="language- extra-class"><pre class="language-text"><code>#加上这条：设置x-pack为开启
xpack.security.enabled: true
设置描述
xpack.graph.enabled 设置为false禁用X-Pack图形功能。
xpack.ml.enabled 设置为false禁用X-Pack机器学习功能。
xpack.monitoring.enabled 设置为false禁用X-Pack监视功能。
xpack.reporting.enabled 设置为false禁用X-Pack报告功能。
xpack.security.enabled 设置为false禁用X-Pack安全功能。
xpack.watcher.enabled 设置false为禁用观察器。
</code></pre></div><p>验证watcher是否启动</p> <p>http://localhost:9200/_watcher/stats?pretty</p> <p><img src="http://stiles.ccdata:image/png;base64,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" alt="../uploads/2020/10/4154064543.png"></p> <p>kibana上安装x-pack kibana也采用本地安装： bin/kibana-plugin install file:x-pack-6.2.4.zip</p> <p>kibana上设置es密码打开 kibana.yml 设置：</p> <div class="language- extra-class"><pre class="language-text"><code>elasticsearch.username: "elastic"
elasticsearch.password: "changme"
</code></pre></div><p>配置报警信息</p> <p>配置文件改动</p> <div class="language- extra-class"><pre class="language-text"><code>watcher.actions.email.service.account:
    work:
        profile: gmail
        email_defaults:
            from: 'John Doe '
            bcc: archive@host.domain
        smtp:
            auth: true
            starttls.enable: true
            host: smtp.gmail.com
            port: 587
            user:
            password:
PUT _xpack/watcher/watch/log_error_watch
{
  "trigger": {
    "schedule": {
      "interval": "10s"
    }
  },
  "input": {
    "search": {
      "request": {
        "indices": ["logs"],
        "body": {
          "query": {
            "match": {
              "message": "error"
            }
          }
        }
      }
    }
  },
  "condition": {
    "compare": {
      "ctx.payload.hits.total": {
        "gt": 0
      }
    }
  },
  "actions" : {
  "send_email" : {
    "email" : {
      "to" : "POST",
      "subject" : "ELK 过去一分钟之内发生过错误请及时关注",
      "body" : "ELK 过去一分钟之内发生过错误请及时关注"
    }
  }
}
}
</code></pre></div><p>logstash配置x-pack:</p> <div class="language- extra-class"><pre class="language-text"><code>vim ./config/logstash.conf

input {
   file {
       path =&gt; "/var/log/messages"
       type =&gt; "systemlog"
      start_position =&gt; "beginning"
       stat_interval =&gt; "3"
   }
}
output {
   if [type] == "systemlog" {
       elasticsearch {
           hosts =&gt; ["127.0.0.1:9200"]
           index =&gt; "system-log-%{+YYYY.MM.dd}"
           user =&gt; "elastic"
           password =&gt; "changme"
       }
   }
}

执行：bin/logstash -f config/logstash.conf
</code></pre></div><p>Sentinl监控插件下载地址https://github.com/sirensolutions/sentinl/releases?after=tag-6.3.2-beta-1</p> <p>kibana安装目录/bin/kibana-plugin install 安装包放的位置/安装包名</p> <p><img src="http://stiles.cc/assets/img/2169785841.0dcfd36b.png" alt="../uploads/2020/10/2169785841.png"></p> <p>sentinl使用方式：可以借鉴https://www.jianshu.com/p/2816c20f8ead</p> <p>参考的资料如下：</p> <p>https://www.cnblogs.com/heyongboke/p/11393069.html</p> <p>https://www.elastic.co/guide/en/elasticsearch/reference/6.2/installing-xpack-es.html</p> <p>https://www.cnblogs.com/cheesebar/p/9126171.html</p> <p>https://www.cnblogs.com/lfwolf/p/6669812.html</p> <p>https://www.jianshu.com/p/2816c20f8ead</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ELK-Windows环境搭建]]></title>
            <link>http://stiles.cc/docs/engineering/ELK-Windows%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/engineering/ELK-Windows%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</guid>
            <pubDate>Thu, 04 Jun 2020 03:12:08 GMT</pubDate>
            <content:encoded><![CDATA[ <p>ELK是Elasticsearch、Logstash、Kibana的简称，这三者是核心组件。</p> <p>Elasticsearch:是数据存储、搜索、分析引擎，功能非常强大；</p> <p>Logstash:是日志的收集、过滤工具；</p> <p>Kibana:可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。</p> <p><img src="http://stiles.cc/assets/img/2639035886.6d777508.jpg" alt="../uploads/2020/10/2639035886.jpg"></p> <p>1:安装步骤</p> <p>官网：https://www.elastic.co/cn/downloads/</p> <p>下载：elasticsearch，Logstash， Kibana</p> <p>(windows选择zip格式下载)</p> <p>elasticsearch：</p> <p>G:\soft\ELK\elasticsearch-7.7.0\config\slasticsearch.yml，修改配置</p> <p>network.host:127.0.0.1 #ES的网络IP</p> <p>http.port: 9200 #ES服务端口</p> <p>进入G:\soft\ELK\elasticsearch-7.7.0\bin 目录执行</p> <p>elasticsearch.bat 启动服务,浏览器打开http://127.0.0.1:9200 展示如下表示启动成功</p> <p><img src="http://stiles.ccdata:image/png;base64,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" alt="../uploads/2020/10/3463548271.png"></p> <p>kibana：</p> <p>调整配置文件：\config\kibana.yml修改如下配置</p> <p>server.port: 5601</p> <p>server.host: "127.0.0.1"</p> <p>elasticsearch.hosts: ["http://127.0.0.1:9200"]</p> <p>启动kibana</p> <p>\bin目录下执行:kibana.bat</p> <p>访问：</p> <p>http://127.0.0.1:5601</p> <p><img src="http://stiles.cc/assets/img/511248373.2fc3c6fd.png" alt="../uploads/2020/10/511248373.png"></p> <p>logstash</p> <p>config目录下添加logstash.conf</p> <div class="language- extra-class"><pre class="language-text"><code>input {
    file {
        path =&gt; "file:/var/log/messages"
        type =&gt; "systemlog"
        start_position =&gt; "beginning"
        stat_interval =&gt; "3"
    }
}
output {
    if [type] == "systemlog" {
        elasticsearch {
            hosts =&gt; ["127.0.0.1:9200"]
            index =&gt; "system-log-%{+YYYY.MM.dd}"
            user =&gt; "elastic"
            password =&gt; "changme"
        }
    }
}
</code></pre></div><p>bin目录下执行命令：logstash -f ../config/logstash.conf</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[kubernetes上部署.net core程序]]></title>
            <link>http://stiles.cc/docs/engineering/kubernetes%E4%B8%8A%E9%83%A8%E7%BD%B2.NetCore%E7%A8%8B%E5%BA%8F.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/engineering/kubernetes%E4%B8%8A%E9%83%A8%E7%BD%B2.NetCore%E7%A8%8B%E5%BA%8F.html</guid>
            <pubDate>Tue, 31 Dec 2019 15:21:08 GMT</pubDate>
            <content:encoded><![CDATA[ <p>19年最后一天梳理了下部署.net core 到腾讯云kubernetes集群上面</p> <p>流程如下：</p> <p>1:打包镜像(使用Dockerfile)</p> <p>2:上传镜像到腾讯云私有仓库</p> <p>3:使用yaml文件创建Deployment,Service使容器run起来</p> <p>流程很简单，让我们开始吧</p> <p>1:打包镜像，在项目发布目录下，创建Dockerfile文件，内容如下</p> <div class="language- extra-class"><pre class="language-text"><code>FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim AS base
#设定工作目录
WORKDIR /app
#在容器中程序使用的端口，一定要和程序启动使用的端口对应上
EXPOSE 80
#复制文件到工作目录
COPY . .

ENTRYPOINT ["dotnet", "Hobby_api.dll"]
</code></pre></div><p>使用docker build构建镜像</p> <div class="language- extra-class"><pre class="language-text"><code>docker build -t 127.0.0.1:5000/hobby-api:v1.1 .
</code></pre></div><p>如无意外，docker images 可查看到镜像</p> <p>2:创建私有仓库push镜像到腾讯云服务器</p> <p>要先创建好宿主机/data/registry目录</p> <div class="language- extra-class"><pre class="language-text"><code>mkdir /data/registry
docker run -itd  -p  5000:5000 -v /data/registry:/var/lib/registry  docker.io/registry
</code></pre></div><p>登录，ip可以相应改成对应ip</p> <div class="language- extra-class"><pre class="language-text"><code>docker login 127.0.0.1:5000
</code></pre></div><p>首次使用输入登录名和密码(第一次输入对账号和密码会自动生成对应账号)</p> <p>推送镜像到私有仓库</p> <div class="language- extra-class"><pre class="language-text"><code>docker push 127.0.0.1:5000/hobby-api:v1.1
</code></pre></div><p>3:创建hobby-api.yaml文件创建Deployment,Service使容器run起来mkdir hobby-api.yaml创建命名空间</p> <div class="language- extra-class"><pre class="language-text"><code>kubectl create namespace hobby
</code></pre></div><p>创建yaml文件apiVersion: apps/v1beta1kind: Deploymentmetadata:name: hobby-apinamespace: hobbyspec:replicas: 1selector:</p> <div class="language- extra-class"><pre class="language-text"><code>matchLabels:
  name: hobby-api
</code></pre></div><p>template:</p> <div class="language- extra-class"><pre class="language-text"><code>metadata:
  labels:
    name: hobby-api
spec:
  containers:
  - name: hobby-api
    image: 127.0.0.1:5000/hobby-api:v1.1
    ports:
    - containerPort: 80
</code></pre></div><hr> <p>apiVersion: v1kind: Servicemetadata:name: hobby-apinamespace: ho</p> <div class="language- extra-class"><pre class="language-text"><code>bby
spec:
  selector:
    name: hobby-api
  type: NodePort
  ports:
    - nodePort: 30091
      port: 80
      protocol: TCP
      targetPort: 80
</code></pre></div><p>执行yaml</p> <div class="language- extra-class"><pre class="language-text"><code>kubectl create -f hobby-api.yaml
</code></pre></div><p><img src="http://stiles.cc/assets/img/100498012.9ef78152.jpg" alt="../uploads/2020/10/100498012.jpg"></p> <p><img src="http://stiles.cc/assets/img/2780905707.b60e80d2.jpg" alt="../uploads/2020/10/2780905707.jpg"></p> <p>总结了下这段时间的研究，为19年拉下序幕，感谢关注@stiles 2019-12-31</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[在docker环境下运行PHP]]></title>
            <link>http://stiles.cc/docs/engineering/%E5%9C%A8docker%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%90%E8%A1%8CPHP.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/engineering/%E5%9C%A8docker%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%90%E8%A1%8CPHP.html</guid>
            <pubDate>Sat, 21 Sep 2019 11:44:08 GMT</pubDate>
            <content:encoded><![CDATA[ <p>Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。</p> <p>官网：https://www.nginx.com/</p> <p>PHP（全称：Hypertext Preprocessor，即: 超文本预处理器"）是一种通用开源脚本语言。</p> <p>官网：https://www.php.net/</p> <p><strong>1.部署PHP环境</strong></p> <p>1.1:拉取PHP</p> <div class="language- extra-class"><pre class="language-text"><code>docker pull php:7.3.5-fpm
</code></pre></div><p>2.1:创建/etc/nginx/www 文件夹用于挂载PHP工作目录</p> <div class="language- extra-class"><pre class="language-text"><code>mkdir /etc/nginx
mkdir /etc/nginx/www
</code></pre></div><p>3.1:运行PHP容器</p> <div class="language- extra-class"><pre class="language-text"><code>docker run --name myphp-fpm -v /etc/nginx/www:/www -d php:7.3.5-fpm
</code></pre></div><p><strong>2:部署nginx环境</strong></p> <p>2.1:拉取nginx镜像</p> <div class="language- extra-class"><pre class="language-text"><code>docker pull nginx
</code></pre></div><p>2.2运行容器</p> <div class="language- extra-class"><pre class="language-text"><code>docker run -p 80:80 --name nginx -d nginx
</code></pre></div><p>2.3:第二步运行的Nginx的配置文件是在容器内部的，不方便修改，所以我们可以先把容器内的配置文件复制到宿主机</p> <p><img src="http://stiles.cc/assets/img/2446934443.33563c79.png" alt="../uploads/2020/10/2446934443.png"></p> <p>2.4:复制容器内的配置文件到宿主机，或者仅复制conf.d文件夹内的配置文件，运行时挂载相应文件即可</p> <div class="language- extra-class"><pre class="language-text"><code>docker cp -a nginx:/etc/nginx/ /etc/nginx/conf
</code></pre></div><p>2.5:停止Nginx容器并删除</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">docker</span> stop nginx
<span class="token function">docker</span> <span class="token function">rm</span> nginx
</code></pre></div><p>2.6:重新运行容器，并挂载我们在第三步复制出来的配置文件目录</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mkdir</span> /etc/nginx/logs
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">--restart</span> always <span class="token parameter variable">--link</span> myphp-fpm:php <span class="token parameter variable">--name</span> nginx <span class="token parameter variable">-v</span> /etc/nginx/www:/usr/share/nginx/html <span class="token parameter variable">-v</span> /etc/nginx/conf/:/etc/nginx/ <span class="token parameter variable">-v</span> /etc/nginx/logs:/var/log/nginx nginx
</code></pre></div><p>2.7:添加测试文件</p> <div class="language- extra-class"><pre class="language-text"><code>mkdir vi /etc/nginx/index.html
内容：ok nginx
</code></pre></div><p>访问localhost:80(我是部署在虚拟机，8080是宿主机和docker虚拟机端口80的映射端口)</p> <p><img src="http://stiles.cc/assets/img/1030161887.5500f94b.png" alt="../uploads/2020/10/1030161887.png"></p> <p>2.8:修改nginx配置</p> <div class="language- extra-class"><pre class="language-text"><code>vi /etc/nginx/conf/conf.d/default.conf
</code></pre></div><p>如下图</p> <p><img src="http://stiles.cc/assets/img/3816535471.c2a9a6bc.png" alt="../uploads/2020/10/3816535471.png"></p> <p>fastcgi_pass myphp-fpm:9000; #将请求代理到容器myphp-fpm到9000端口</p> <h1 id="这个命令是指定将http代理到哪个fastcgi服务端接口。fastcgi-pass后面是填写fastcgi服务端地址的-这个地址可以是域地址-也可以是uninx-域套接字。"><strong>这个命令是指定将http代理到哪个fastcgi服务端接口。fastcgi_pass后面是填写fastcgi服务端地址的，这个地址可以是域地址，也可以是Uninx-域套接字。</strong></h1> <p>fastcgi_param SCRIPT_FILENAME $/www/$fastcgi_script_name;</p> <h1 id="脚本文件请求的路径-www-映射宿主机挂载的-etc-nginx-www目录-这里是个大坑"><strong>脚本文件请求的路径 (/www/ 映射宿主机挂载的/etc/nginx/www目录，这里是个大坑)</strong></h1> <p>2.9:创建index.php文件测试结果</p> <div class="language- extra-class"><pre class="language-text"><code>vi /etc/nginx/www/index.php
</code></pre></div><p>内容如下</p> <p><img src="http://stiles.cc/assets/img/1089567996.07329fdb.png" alt="../uploads/2020/10/1089567996.png"></p> <p>重启nginx容器使配置生效</p> <div class="language- extra-class"><pre class="language-text"><code>docker restart nginx
</code></pre></div><p>如无意外访问localhost:80/index.php 可看到如下界面</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[基于Jenkins+tfs+msbuild实现自动发布]]></title>
            <link>http://stiles.cc/docs/engineering/%E5%9F%BA%E4%BA%8EJenkins+tfs+msbuild%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/engineering/%E5%9F%BA%E4%BA%8EJenkins+tfs+msbuild%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83.html</guid>
            <pubDate>Mon, 15 Jul 2019 06:22:08 GMT</pubDate>
            <content:encoded><![CDATA[ <p>Jenkins是一款开源 CI&amp;CD 软件，用于自动化各种任务，包括构建、测试和部署软件.</p> <p>官网地址:Jenkins, 默认端口8080</p> <p><strong>初始化jenkins</strong></p> <p>1.浏览器输入：</p> <p>http://localhost:8080</p> <p>解锁jenkins</p> <p><img src="http://stiles.cc/assets/img/251376409.cc3b242c.jpg" alt="../uploads/2020/10/251376409.jpg"></p> <p>在如图所示的路径下面打开initialAdminPassword文件，复制密码输入即可</p> <p>2.自定义Jenkins ，选择安装推荐的插件</p> <p><img src="http://stiles.cc/assets/img/2557773529.0220c0c9.jpg" alt="../uploads/2020/10/2557773529.jpg"></p> <ol><li>安装MSBuild和TFS插件安装</li></ol> <p>在Manage Jenkins 的 Manage Plugin 里面我们找到 MSBuild 和 Team Foundation Server Plug-in 插件，勾选，点击 Download now and install after restart 按钮，勾选 Restart Jenkins when installation is complete and no jobs are running 。</p> <p><img src="http://stiles.cc/assets/img/3462620899.64b9b88a.jpg" alt="../uploads/2020/10/3462620899.jpg"></p> <p><img src="http://stiles.cc/assets/img/4037582657.baba7c02.jpg" alt="../uploads/2020/10/4037582657.jpg"></p> <p><img src="http://stiles.cc/assets/img/3869712054.0a3ab79e.jpg" alt="../uploads/2020/10/3869712054.jpg"></p> <p>安装完成之后 Jenkins 会重启，等待重启完毕之后，来到 Jenkins&gt;&gt;Global Tool Configuration 查看 MSBuild配置msbuild的路径，我这边是安装了vs2017在安装目录下面可以找到MSBuild路径，如下图：</p> <p><img src="http://stiles.cc/assets/img/1621096654.652525f3.jpg" alt="../uploads/2020/10/1621096654.jpg"></p> <p><strong>项目构建</strong></p> <p>选择FreeStyle Project(自由风格的构建)，相关配置如下图</p> <p><img src="http://stiles.cc/assets/img/2719988944.e44b9309.jpg" alt="../uploads/2020/10/2719988944.jpg"></p> <p><img src="http://stiles.cc/assets/img/3790967767.495b3bb2.jpg" alt="../uploads/2020/10/3790967767.jpg"></p> <p><img src="http://stiles.cc/assets/img/1900698993.e34d4183.jpg" alt="../uploads/2020/10/1900698993.jpg"></p> <p>MSBuild参数说明如下：</p> <p>/t:Rebuild (每次都是重新构建)/p:Configuration=Release （构建的是发布版本）/p:VisualStudioVersion=15.0 （vs的版本,使用的是2017填写的是15.0）/p:WebProjectOutputDir=D:\wwwroot\test （发布路径）/p:OutputPath=D:\wwwroot\test\bin (输出路径)/p:DeployOnBuild=True （表示启用编译并发布）</p> <p>msbuild文档：<a href="https://learn.microsoft.com/zh-cn/visualstudio/msbuild/msbuild?view=vs-2022" target="_blank" rel="noopener noreferrer">点击查看文档<span> </span></a></p> <p>msbuild15版本离线下载文件：<a href="https://www.microsoft.com/zh-CN/download/details.aspx?id=48159" target="_blank" rel="noopener noreferrer">点击下载<span> </span></a></p> <p>执行windows批处理命令复制目录文件到对应站点下面</p> <p><img src="http://stiles.cc/assets/img/1638465169.b87615cc.jpg" alt="../uploads/2020/10/1638465169.jpg"></p> <p>xcope source [destination] [命令参数]</p> <p>source 指定要复制的文件</p> <p>destination 指定新文件的位置和/或名称。</p> <p>/s 复制目录和子目录，除了空的</p> <p>/e 复制目录和子目录，包括空的</p> <p>/y 禁止提示以确认改写一个现存目标文件</p> <p>/s /e /y 表示完成拷贝； exclude</p> <p>exclude 指定含有字符串的文件列表。每个字符串在文件中应位于单独的一行。如果任何字符串与复制文件的绝对路径的任何部分相符，则排除复制该文件。例如，指定如 \obj\ 或 .obj 的字符串会分别排除目录 obj 下面的所有文件或带有.obj 扩展名的所有文件。</p> <p><img src="http://stiles.cc/assets/img/75287297.853e4feb.jpg" alt="../uploads/2020/10/75287297.jpg"></p> <p>手动构建项目,完成构建-发布的流程</p> <p><img src="http://stiles.cc/assets/img/1217804723.d620459f.jpg" alt="../uploads/2020/10/1217804723.jpg"></p> <p><img src="http://stiles.cc/assets/img/1404944688.cad6786b.jpg" alt="../uploads/2020/10/1404944688.jpg"></p> <p><strong>总结</strong></p> <p>整个流程通过tfs 拉取项目到jenkins安装目录的workspace目录下面，再通过msbuild编译和预发布到指定的目录，确保无误之后再通过windows xcopy命令覆盖到指定站点路径下面（此处根据需要还可以添加站点的备份）完成整个自动编译到发布的流程。</p> <p><strong>参考资料</strong></p> <p><a href="https://www.cnblogs.com/tianyang1027/p/10333454.html" target="_blank" rel="noopener noreferrer">jekins+TFS+MsBuild实现.net的持续集成，自动化部署<span> </span></a></p> <p><a href="https://www.cnblogs.com/edisonchou/p/CD_foundation_based_on_jenkins_and_docker.html" target="_blank" rel="noopener noreferrer">.NET Core微服务之基于Jenkins+Docker实现持续部署（Part 1）<span> </span></a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SqlServer AlwaysOn搭建]]></title>
            <link>http://stiles.cc/docs/engineering/SqlServer-AlwaysOn%E6%90%AD%E5%BB%BA.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/engineering/SqlServer-AlwaysOn%E6%90%AD%E5%BB%BA.html</guid>
            <pubDate>Sun, 09 Jun 2019 13:14:08 GMT</pubDate>
            <content:encoded><![CDATA[ <p><strong>什么是Always On</strong></p> <p>always on其实是指在sql server中实现高可用的解决方案之一，其实际是部署在Windows集群上的一个应用程序，是需要部署一个Windows故障转移集群（WSFC）。SQLServer集群则是部署Windows集群每个节点上的SQLServer应用。</p> <p>官方文档 : AlwaysOn 可用性组概述 (SQL Server)</p> <p><strong>第一步.安装故障转移集群</strong></p> <p>各个服务器节点都要安装故障转移集群</p> <p><img src="http://stiles.cc/assets/img/3162580750.d8a06617.png" alt="../uploads/2020/10/3162580750.png"></p> <p><img src="http://stiles.cc/assets/img/1168153852.ae526cbe.png" alt="../uploads/2020/10/1168153852.png"></p> <p><strong>第二步：此处演示无域搭建故障转移集群的方式，每个节点的计算机不需要加入域，但需要添加DNS后缀，且每个节点的后缀必须要相同，如下图所示的操作</strong></p> <p>DNS后缀和主机名可以随便取，DNS后缀 各个节点一致即可</p> <p><img src="http://stiles.cc/assets/img/4142944059.6e6a3e91.png" alt="../uploads/2020/10/4142944059.png"></p> <p><strong>第三步：在每个节点上都添加一个用户，且用户名以及密码每个节点都一致,并添加率属于Administrators，此处为DCAdmin.</strong></p> <p><img src="http://stiles.cc/assets/img/2421550577.3eb21575.png" alt="../uploads/2020/10/2421550577.png"></p> <p><strong>第四步：在每个节点的 hosts 文件中添加节点的计算机信息、群集信息、侦听器信息。</strong></p> <p>hosts文件路径：C:\Windows\System32\drivers\etc</p> <p><img src="http://stiles.cc/assets/img/2479369613.7316c45a.png" alt="../uploads/2020/10/2479369613.png"></p> <p><strong>第五步：调整sql server 服务账号，设置sql服务引擎和代理服务，登录账号调整为之前的添加的账号DCAdmin</strong></p> <p><img src="http://stiles.cc/assets/img/3222947489.c616dbaf.png" alt="../uploads/2020/10/3222947489.png"></p> <p><img src="http://stiles.cc/assets/img/486419465.6237c42e.png" alt="../uploads/2020/10/486419465.png"></p> <p><strong>第六步：使用sa账号登录sql server 添加前面添加的DCAdmin账号,并且赋予sysadmin权限</strong></p> <p><img src="http://stiles.cc/assets/img/1355110498.edc71813.png" alt="../uploads/2020/10/1355110498.png"></p> <p><img src="http://stiles.cc/assets/img/1250790354.9536585a.png" alt="../uploads/2020/10/1250790354.png"></p> <p><strong>第七步：设置内网ip4配置</strong></p> <p>1.点击高级选择dns,如下图填入上文定义的dns</p> <p>2选择WINS-&gt;NetBIOS设置，勾选禁用TCP/IP上的NetBIOS</p> <p><img src="http://stiles.cc/assets/img/3540666399.162bad56.png" alt="../uploads/2020/10/3540666399.png"></p> <p><img src="http://stiles.cc/assets/img/1938948609.c71de3f8.png" alt="../uploads/2020/10/1938948609.png"></p> <p><strong>第八步：配置注册表，把LocalAccountTokenFilterPolicy的值设置为1，配置方法：</strong></p> <p>1.在【运行】对话框输入【regedit】，单击【确定】按钮</p> <p>2.进入路径HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System</p> <p>3.新建DWORD(32位)值(D) 名称为：LocalAccountTokenFilterPolicy 值为1，16进制。</p> <p><img src="http://stiles.cc/assets/img/3796803176.26da37e4.png" alt="../uploads/2020/10/3796803176.png"></p> <p><strong>第九步：设置允许应用和功能通过防火墙，如下图配置</strong></p> <p><img src="http://stiles.cc/assets/img/3206538110.5ae119e8.png" alt="../uploads/2020/10/3206538110.png"></p> <p><img src="http://stiles.cc/assets/img/3368305949.f0de3f20.png" alt="../uploads/2020/10/3368305949.png"></p> <p><img src="http://stiles.cc/assets/img/3049339700.8546526e.png" alt="../uploads/2020/10/3049339700.png"></p> <p>以下开始搭建故障转移集群</p> <p>选择验证配置，服务机集群填入之前配置的多个节点的主机名，后选择添加即可,其它选项下一步。</p> <p>生成摘要报告后选择创建集群</p> <p><img src="http://stiles.cc/assets/img/1691913758.70a68ced.png" alt="../uploads/2020/10/1691913758.png"></p> <p>在各个节点上开启sql server alwaysOn可用性组，设置后重启服务才生效。</p> <p><img src="http://stiles.cc/assets/img/343398361.b0262f9e.png" alt="../uploads/2020/10/343398361.png"></p> <p>重启后查看服务器属性，确认HADR是True</p> <p><img src="http://stiles.cc/assets/img/1858383828.c3519040.png" alt="../uploads/2020/10/1858383828.png"></p> <p>接下来是配置可用性组，可用性组侦听器 ，参考： 从0开始搭建SQL Server AlwaysOn 第三篇 第八点开始即可，就不多此一举。</p> <p>最后结果如下。</p> <p><img src="http://stiles.cc/assets/img/886660607.0c9a2ffd.png" alt="../uploads/2020/10/886660607.png"></p> <p>参考资料</p> <p><a href="https://blog.csdn.net/dongxinhjj/article/details/80817333" target="_blank" rel="noopener noreferrer">配置sqlServer 2016 无域AlwaysOn<span> </span></a></p> <p><a href="https://www.cnblogs.com/lyhabc/p/4678330.html" target="_blank" rel="noopener noreferrer">从0开始搭建SQL Server AlwaysOn<span> </span></a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[centos上搭建redis集群]]></title>
            <link>http://stiles.cc/docs/engineering/centos%E4%B8%8A%E6%90%AD%E5%BB%BAredis%E9%9B%86%E7%BE%A4.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/engineering/centos%E4%B8%8A%E6%90%AD%E5%BB%BAredis%E9%9B%86%E7%BE%A4.html</guid>
            <pubDate>Tue, 12 Mar 2019 14:30:08 GMT</pubDate>
            <content:encoded><![CDATA[ <p>简介：Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施（installation）。</p> <p><strong>集群的理解</strong>为何使用集群：解决单机故障，和单台服务器性能瓶颈的问题</p> <p>提升系统负载，引入集群也引入了集群间节点通信和数据同步的一致性问题，和系统高可用的问题。</p> <p><img src="http://stiles.cc/assets/img/2303071062.3a9232e5.png" alt="../uploads/2020/10/2303071062.png"></p> <p><strong>1.安装环境依赖</strong></p> <div class="language- extra-class"><pre class="language-text"><code>yum -y install gcc automake autoconf libtool make
yum install gcc-c++
</code></pre></div><p><strong>2.下载redis软件包，解压并安装</strong></p> <div class="language- extra-class"><pre class="language-text"><code> cd /usr/local/software
 wget &lt;http://download.redis.io/releases/redis-5.0.3.tar.gz&gt;
 tar xzf redis-5.0.3.tar.gz
 cd redis-5.0.3
 make &amp;&amp; make install
</code></pre></div><p><img src="http://stiles.cc/assets/img/2144204738.f44e8422.png" alt="../uploads/2020/10/2144204738.png"></p> <p><strong>3.建立软件以及节点运行目录，复制配置文件</strong></p> <div class="language- extra-class"><pre class="language-text"><code>cd /usr/local
mkdir redis-cluster
cd redis-cluster
mkdir redis-node-7000 redis-node-7001 redis-node-7002 redis-node-7003 redis-node-7004 redis-node-7005 redis-node-7006
redis-node-7007
cd redis-node1
mkdir logs data
cd /usr/local/software/redis-5.0.3
cp redis.conf /usr/local/redis-cluster/redis-node-7000
cp redis.conf /usr/local/redis-cluster/redis-node-7001
cp redis.conf /usr/local/redis-cluster/redis-node-7002
cp redis.conf /usr/local/redis-cluster/redis-node-7003
cp redis.conf /usr/local/redis-cluster/redis-node-7004
cp redis.conf /usr/local/redis-cluster/redis-node-7005
cp redis.conf /usr/local/redis-cluster/redis-node-7006
cp redis.conf /usr/local/redis-cluster/redis-node-7007

cd src
cp redis-cli redis-server   /usr/local/redis-cluster/redis-node-7000
cp redis-cli redis-server   /usr/local/redis-cluster/redis-node-7001
cp redis-cli redis-server   /usr/local/redis-cluster/redis-node-7002
cp redis-cli redis-server   /usr/local/redis-cluster/redis-node-7003
cp redis-cli redis-server   /usr/local/redis-cluster/redis-node-7004
cp redis-cli redis-server   /usr/local/redis-cluster/redis-node-7005
cp redis-cli redis-server   /usr/local/redis-cluster/redis-node-7006
cp redis-cli redis-server   /usr/local/redis-cluster/redis-node-7007
</code></pre></div><p><strong>4.修改配置文件</strong></p> <div class="language- extra-class"><pre class="language-text"><code>cd /usr/local/redis-cluster/redis-node-7000
vi redis.conf
--文件内容如下
port 7000 //端口7000,7002,7003..
bind 本机ip //默认ip为127.0.0.1 需要改为其他节点机器可访问的ip 否则创建集群时无法访问对应的端口，无法创建集群
daemonize yes //redis后台运行
pidfile /usr/local/redis-cluster/redis-node-7000/redis_7000.pid //pidfile文件对应7000,7001,7002,7003,7004,7005,7006,7007
cluster-enabled yes //开启集群 把注释#去掉
cluster-config-file nodes_7000.conf //集群的配置 配置文件首次启动自动生成 7000,7001,7002,7003..
cluster-node-timeout 15000 //请求超时 默认15秒，可自行设置
appendonly yes //aof日志开启 有需要就开启，它会每次写操作都记录一条日志
logfile "/usr/local/redis-cluster/redis-node-7000/logs/redis_7000.log" //配置日志文件路径 dir "/usr/local/redis-cluster/redis-5.0.3-node/data"　　//配置数据文件存放路径
dir "/usr/local/redis-cluster/redis-node-7000/data"
</code></pre></div><p><strong>5.启动各个节点</strong>cd /usr/local/redis-cluster/redis-node-7000</p> <div class="language- extra-class"><pre class="language-text"><code>redis-server redis.conf
</code></pre></div><p>查看启动情况</p> <div class="language- extra-class"><pre class="language-text"><code>ps -ef | grep redis
</code></pre></div><p><img src="http://stiles.cc/assets/img/3807803297.e7d78cdb.png" alt="../uploads/2020/10/3807803297.png"></p> <div class="language- extra-class"><pre class="language-text"><code>6.初始化集群（节点列表顺序用于确定主从角色，先主节点之后是从节点）

cd /usr/local/redis-cluster

redis-cli  --cluster create  --cluster-replicas  1  192.168.50.230:7000 192.168.50.230:7001  192.168.50.230:7002 192.168.50.230:7003  192.168.50.230:7004  192.168.50.230:7005 192.168.50.230:7006 192.168.50.230:7007
</code></pre></div><p><img src="http://stiles.cc/assets/img/3603667446.db86fd66.png" alt="../uploads/2020/10/3603667446.png"></p> <p>查看集群信息</p> <div class="language- extra-class"><pre class="language-text"><code>redis-cli -c -h 192.168.50.230 -p 7000
cluster info
</code></pre></div><p><img src="http://stiles.cc/assets/img/2502187957.36afd53e.png" alt="../uploads/2020/10/2502187957.png"></p> <p>检查集群信息</p> <div class="language- extra-class"><pre class="language-text"><code>redis-cli --cluster check 192.168.50.230:7000
</code></pre></div><p><strong>参考资料</strong></p> <p><a href="https://www.cnblogs.com/coes/p/9031939.html" target="_blank" rel="noopener noreferrer">centos7快速搭建redis集群环境<span> </span></a></p> <p><a href="https://blog.csdn.net/qq_36514588/article/details/83856795" target="_blank" rel="noopener noreferrer">redis5.0.0集群搭建-centos7<span> </span></a></p> <p><a href="http://www.mamicode.com/info-detail-1843956.html" target="_blank" rel="noopener noreferrer">安装redis出现cc adlist.0 /bin/sh:1:cc:not found<span> </span></a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[kubernetes-Dashboard账号]]></title>
            <link>http://stiles.cc/docs/engineering/kubernetes-Dashboard%E8%B4%A6%E5%8F%B7.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/engineering/kubernetes-Dashboard%E8%B4%A6%E5%8F%B7.html</guid>
            <pubDate>Thu, 27 Dec 2018 12:31:08 GMT</pubDate>
            <content:encoded><![CDATA[ <p>简介：作为Kubernetes的Web用户界面，用户可以通过Dashboard在Kubernetes集群中部署容器化的应用，对应用进行问题处理和管理，并对集群本身进行管理。本文介绍下dashboard的安装过程。</p> <p><strong>1：安装kubernetes dashboard</strong></p> <div class="language- extra-class"><pre class="language-text"><code>kubectl create -f &lt;https://raw.githubusercontent.com/kubernetes/dashboard/master/aio/deploy/recommended/kubernetes-dashboard.yaml&gt;
</code></pre></div><p><strong>2: 创建账号</strong></p> <p>创建kubernetes-dashboard.yaml文件内容如下</p> <div class="language- extra-class"><pre class="language-text"><code>apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kube-system
</code></pre></div><p>执行</p> <div class="language- extra-class"><pre class="language-text"><code>kubectl create -f kubernetes-dashboard.yaml
</code></pre></div><p><strong>3：绑定到ClusterRole</strong></p> <p>创建ClusterRoleBinding.yaml文件内容如下</p> <div class="language- extra-class"><pre class="language-text"><code>apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kube-system
</code></pre></div><p>执行</p> <div class="language- extra-class"><pre class="language-text"><code>kubectl create -f ClusterRoleBinding.yaml
</code></pre></div><p><strong>4:获取管理员用户的Token</strong></p> <div class="language- extra-class"><pre class="language-text"><code>kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}')
</code></pre></div><p>你会看到打印出类似：</p> <div class="language- extra-class"><pre class="language-text"><code>Name:         admin-user-token-6gl6l
Namespace:    kube-system
Labels:
Annotations:  kubernetes.io/service-account.name=admin-user
              kubernetes.io/service-account.uid=b16afba9-dfec-11e7-bbb9-901b0e532516

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1025 bytes
namespace:  11 bytes
token:      eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLTZnbDZsIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJiMTZhZmJhOS1kZmVjLTExZTctYmJiOS05MDFiMGU1MzI1MTYiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06YWRtaW4tdXNlciJ9.M70CU3lbu3PP4OjhFms8PVL5pQKj-jj4RNSLA4YmQfTXpPUuxqXjiTf094_Rzr0fgN_IVX6gC4fiNUL5ynx9KU-lkPfk0HnX8scxfJNzypL039mpGt0bbe1IXKSIRaq_9VW59Xz-yBUhycYcKPO9RM2Qa1Ax29nqNVko4vLn1_1wPqJ6XSq3GYI8anTzV8Fku4jasUwjrws6Cn6_sPEGmL54sq5R4Z5afUtv-mItTmqZZdxnkRqcJLlg2Y8WbCPogErbsaCDJoABQ7ppaqHetwfM_0yMun6ABOQbIwwl8pspJhpplKwyo700OSpvTT9zlBsu-b35lzXGBRHzv5g_RA
</code></pre></div><p>复制token输入即可</p> <p><img src="http://stiles.cc/assets/img/1561250293.acc62d5d.jpg" alt="../uploads/2020/10/1561250293.jpg"></p> <p>参考资料：</p> <p><a href="https://github.com/kubernetes/dashboard/wiki/Creating-sample-user" target="_blank" rel="noopener noreferrer">Creating sample user<span> </span></a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[.NET Core on K8S入门演示]]></title>
            <link>http://stiles.cc/docs/engineering/NET%20Core%20on%20K8S%E5%85%A5%E9%97%A8%E6%BC%94%E7%A4%BA.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/engineering/NET%20Core%20on%20K8S%E5%85%A5%E9%97%A8%E6%BC%94%E7%A4%BA.html</guid>
            <pubDate>Sun, 25 Nov 2018 08:12:01 GMT</pubDate>
            <content:encoded><![CDATA[ <p><strong>前言</strong></p> <p><a href="http://xn--jessetalk-zb6ng3abn959kfm9e.NET" target="_blank" rel="noopener noreferrer">学习了下jessetalk的.NET<span> </span></a> Core on K8S快速入门课程 有兴趣的同学可以通过http://video.jessetalk.cn报名，我这里简单的做了下笔记</p> <p>Docker: 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p> <p>Kubernetes：Kubernetes是Google开源的容器集群管理系统，实现基于Docker构建容器，利用Kubernetes能很方面管理多台Docker主机中的容器。</p> <p>kubectl:客户端命令行工具，将接受的命令格式化后发送给kube-apiserver，作为整个系统的操作入口</p> <p>chocolately:强大的windows 软件包管理工具</p> <p><strong>安装docker</strong>从Docker官方站点下载并安装Docker for Mac或Docker for Windows</p> <p><strong>设置docker</strong>在 Docker -&gt;Settings-&gt; Daemon 中，配置 registry mirror 为 https://registry.docker-cn.com</p> <p><img src="http://stiles.cc/assets/img/1255480260.c1791cd0.jpg" alt="../uploads/2020/10/1255480260.jpg"></p> <p>加载镜像</p> <p>运行下列脚本可以从阿里云镜像服务下载Kubernetes安装所需Docker镜像</p> <div class="language- extra-class"><pre class="language-text"><code>git clone &lt;https://github.com/AliyunContainerService/k8s-for-docker-desktop&gt;
cd k8s-for-docker-desktop
</code></pre></div><p>windows10环境下进入对应k8s-for-docker-desktop目录选中load_images.ps1右击使用PowerShell运行,即可下载对应镜像</p> <p>开启Kubernetes</p> <p>在docker开启 Kubernetes，等待如下消息 Kubernetes is running</p> <p><img src="http://stiles.cc/assets/img/2910838400.e96757a5.jpg" alt="../uploads/2020/10/2910838400.jpg"></p> <p><strong>安装 chocolately</strong></p> <p>使用管理员权限打开PowerShell执行</p> <div class="language- extra-class"><pre class="language-text"><code>Set-ExecutionPolicy Bypass -Scope Process -Force;
iex ((New-Object System.Net.WebClient).DownloadString('&lt;https://chocolatey.org/install.ps1&gt;'))
</code></pre></div><p><strong>使用Chocolately安装kubectl</strong></p> <div class="language- extra-class"><pre class="language-text"><code>choco install kubernetes-cli
kubectl version
</code></pre></div><p><strong>验证 Kubernetes 安装</strong></p> <div class="language- extra-class"><pre class="language-text"><code>kubectl cluster-info
kubectl get nodes
</code></pre></div><p><strong><a href="http://xn--5brr72ac28a2bq.net" target="_blank" rel="noopener noreferrer">创建默认.net<span> </span></a> core web项目</strong></p> <p>使用名称为K8s-demo，用于演示使用.</p> <p><strong>创建Dockerfile文件</strong></p> <div class="language- extra-class"><pre class="language-text"><code>FROM microsoft/dotnet:2.1-aspnetcore-runtime AS base
WORKDIR /app
EXPOSE 80

FROM microsoft/dotnet:2.1-sdk AS build
WORKDIR /src
COPY . .

RUN dotnet restore
RUN dotnet build  -c Release -o /app

FROM build AS publish
RUN dotnet publish -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "K8s-demo.dll"]
</code></pre></div><p><strong>发布到docker</strong></p> <div class="language- extra-class"><pre class="language-text"><code>docker build -t stilesboy/k8s-demo .
</code></pre></div><p><strong>实例化容器</strong></p> <div class="language- extra-class"><pre class="language-text"><code>docker run -d -p 8085:80 --name k8s-demo stilesboy/k8s-demo
</code></pre></div><p><strong><a href="http://xn--hub-7j2ep21fi04d.docker.com" target="_blank" rel="noopener noreferrer">推送到hub.docker.com<span> </span></a></strong></p> <p>需要先行注册账号,<a href="http://xn--3ds.net" target="_blank" rel="noopener noreferrer">在.net<span> </span></a> core目录下执行</p> <div class="language- extra-class"><pre class="language-text"><code>docker login --username stilesboy
docker push stilesboy/k8s-demo
</code></pre></div><p>创建namespace</p> <div class="language- extra-class"><pre class="language-text"><code>kubectl create namespace netcore
</code></pre></div><p><strong>创建deploy.yaml文件</strong></p> <div class="language- extra-class"><pre class="language-text"><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: k8s-demo
  namespace: netcore
  labels:
    name: k8s-demo
spec:
    replicas: 2
    selector:
      matchLabels:
        name: k8s-demo
    template:
        metadata:
          labels:
            name: k8s-demo
        spec:
          containers:
          - name: k8s-demo
            image: stilesboy/k8s-demo
            ports:
            - containerPort: 80
            imagePullPolicy: Always

---

kind: Service
apiVersion: v1
metadata:
  name: k8s-demo
  namespace: netcore
spec:
  type: NodePort
  ports:
   - port: 80
     targetPort: 80
  selector:
      name: k8s-demo
</code></pre></div><p><strong>创建K8S service</strong></p> <div class="language- extra-class"><pre class="language-text"><code>kubectl create -f deploy.yaml
</code></pre></div><p><strong>查看服务</strong></p> <div class="language- extra-class"><pre class="language-text"><code>kubectl get service -n netcore
</code></pre></div><p><img src="http://stiles.ccdata:image/jpeg;base64,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" alt="../uploads/2020/10/387211778.jpg"></p> <p>本例子查看对应曝露的端口地址为30786</p> <p>使用浏览器打开http://127.0.0.1:30786/api/values</p> <p><strong>安装Dashboard UI</strong></p> <p>kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/master/aio/deploy/recommended/kubernetes-dashboard.yaml</p> <p><strong>开启API Server的本地监听端口</strong></p> <div class="language- extra-class"><pre class="language-text"><code>kubectl proxy
</code></pre></div><p>打开控制台</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/service?namespace=netcore&gt;
</code></pre></div><p><img src="http://stiles.cc/assets/img/3436794993.7aecf05d.jpg" alt="../uploads/2020/10/3436794993.jpg"></p> <p>参考资料：</p> <p><a href="https://developer.aliyun.com/article/508460" target="_blank" rel="noopener noreferrer">Docker社区版中Kubernetes开发<span> </span></a><a href="http://video.jessetalk.cn/" target="_blank" rel="noopener noreferrer">.NET Core on K8S快速入门课程<span> </span></a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[小程序开发介绍]]></title>
            <link>http://stiles.cc/docs/other/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/other/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D.html</guid>
            <pubDate>Fri, 07 Sep 2018 14:47:01 GMT</pubDate>
            <content:encoded><![CDATA[ <p><strong>1.小程序诞生的背景</strong></p> <p><img src="http://stiles.cc/assets/img/4019366196.de03bcf0.jpg" alt="../uploads/2020/10/4019366196.jpg"></p> <p>1.1：微信小程序，简称小程序，英文名Mini Program。是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。</p> <p>1.2：2017年1月9日，张小龙在2017微信公开课Pro上发布的小程序正式上线。</p> <p>1.3：微信要打造一个以微信为中心的生态链，不以绑定用户为目标。比如生活中有一些不太常用的app，我们可能一年也使用不了几次，但是有时候就需要用到，微信就想要提供这样一个平台，让你可以在微信中使用这中所谓的app的功能。或者说可以这样理解，让微信成为一个类似于Windows的操作系统，各种小程序就是操作系统上的应用软件。</p> <p><strong>2.开发者工具和文档</strong>开发文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener noreferrer">点击这里<span> </span></a>。申请账号：<a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1" target="_blank" rel="noopener noreferrer">点击这里<span> </span></a>，根据指引填写信息和提交相应的资料，就可以拥有自己的小程序帐号。</p> <p>Windows 64位：<a href="https://servicewechat.com/wxa-dev-logic/download_redirect?type=x64&amp;from=mpwiki&amp;t=1474644089434" target="_blank" rel="noopener noreferrer">点我下载<span> </span></a></p> <p>Windows 32位：<a href="https://servicewechat.com/wxa-dev-logic/download_redirect?type=ia32&amp;from=mpwiki&amp;t=1474644089434" target="_blank" rel="noopener noreferrer">点我下载<span> </span></a></p> <p>Mac 版 ：<a href="https://servicewechat.com/wxa-dev-logic/download_redirect?type=darwin&amp;from=mpwiki&amp;t=1474644089434" target="_blank" rel="noopener noreferrer">点我下载<span> </span></a></p> <p><strong>3.开发介绍</strong></p> <p>从事过网页编程的人知道，网页编程采用的是 HTML + CSS + JS 这样的组合，其中 HTML 是用来描述当前这个页面的结构，CSS 用来描述页面的样子，JS 通常是用来处理这个页面和用户的交互。</p> <p>同样道理，在小程序中也有同样的角色，其中 WXML 充当的就是类似 HTML 的角色，WXSS 充当的就是类似 CSS 的角色,具有 CSS 大部分的特性.样式支持详情点击这里</p> <p>小程序自有一套基础组件，包括view,scroll-view,icon,progress,image,video,map等</p> <p>在小程序开发中大部分使用Flex布局：</p> <p>Flex 布局教程：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener noreferrer">语法篇<span> </span></a>Flex 布局教程：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener noreferrer">实例篇<span> </span></a></p> <p>小程序默认项目结构</p> <p><img src="http://stiles.cc/assets/img/3356873714.444bae80.png" alt="../uploads/2020/10/3356873714.png"></p> <p>app.wxss 的样式默认全局使用,可以配置一些通用样式。
在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。
app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。
pages目录下的js中的方法，onLoad、onShow、onReady、onHide、onUnload 是页面的生命周期函数，分别在页面加载、显示、初次渲染完成、隐藏和卸载时调用。其中onLoad和onReady只会在页面加载时调用一次，onShow则每次显示页面都会调用一次。</p> <p><strong>4.总结</strong></p> <p>本篇简单介绍了下小程序，和记录了下基本的几个知识点，后续在介绍下详细的开发案例。</p> <p><strong>5.参考资料</strong></p> <p><a href="https://www.cnblogs.com/edisonchou/p/6081851.html" target="_blank" rel="noopener noreferrer">微信小程序开发初探<span> </span></a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[RabbitMQ介绍]]></title>
            <link>http://stiles.cc/docs/rabbitmq/RabbitMQ%E4%BB%8B%E7%BB%8D.html</link>
            <guid isPermaLink="true">http://stiles.cc/docs/rabbitmq/RabbitMQ%E4%BB%8B%E7%BB%8D.html</guid>
            <pubDate>Sat, 23 Jun 2018 11:52:01 GMT</pubDate>
            <content:encoded><![CDATA[ <p><strong>1.RabbitMQ介绍</strong></p> <p>RabbitMQ：是采用Erlang实现的给予AMQP协议标准的消息队列，建立在Erlang OTP平台上。</p> <p>安装顺序如下：</p> <p>1：http://www.erlang.org/downloads，下载Erlang OTP安装包。</p> <p>2：http://www.rabbitmq.com/install-windows.html，下载rabbitmq安装包。</p> <p><strong>2. AMQP messaging 中的基本概念</strong></p> <p><img src="http://stiles.cc/assets/img/4051105280.99ce4d15.jpg" alt="../uploads/2020/10/4051105280.jpg"></p> <p><strong>Broker</strong>: 接收和分发消息的应用，RabbitMQ Server就是Message Broker。<strong>Virtual host</strong>: 出于多租户和安全因素设计的，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的namespace概念。当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange／queue等。<strong>Connection</strong>: publisher／consumer和broker之间的TCP连接。断开连接的操作只会在client端进行，Broker不会断开连接，除非出现网络故障或broker服务出现问题。<strong>Channel</strong>: 如果每一次访问RabbitMQ都建立一个Connection，在消息量大的时候建立TCP Connection的开销将是巨大的，效率也较低。Channel是在connection内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，AMQP method包含了channel id帮助客户端和message broker识别channel，所以channel之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销。<strong>Exchange</strong>: message到达broker的第一站，根据分发规则，匹配查询表中的routing key，分发消息到queue中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。<strong>Queue</strong>: 消息最终被送到这里等待consumer取走。一个message可以被同时拷贝到多个queue中。<strong>Binding</strong>: exchange和queue之间的虚拟连接，binding中可以包含routing key。Binding信息被保存到exchange中的查询表中，用于message的分发依据。<strong>3.Exchange类型</strong></p> <p>Exchange有多种类型，最常用的是Direct／Fanout／Topic三种类型。</p> <p><strong>Direct</strong></p> <p><img src="http://stiles.cc/assets/img/1951361367.fdf25b89.png" alt="../uploads/2020/10/1951361367.png"></p> <p>Message中的“routing key”如果和Binding中的“binding key”一致， Direct exchange则将message发到对应的queue中。</p> <p><strong>Fanout</strong></p> <p><img src="http://stiles.cc/assets/img/4139690241.1ff7b6ec.png" alt="../uploads/2020/10/4139690241.png"></p> <p>每个发到Fanout类型Exchange的message都会分到所有绑定的queue上去。</p> <p><strong>Topic</strong></p> <p><img src="http://stiles.cc/assets/img/321849651.0e2ae37d.png" alt="../uploads/2020/10/321849651.png"></p> <p>根据routing key，及通配规则，Topic exchange将分发到目标queue中。Routing key中可以包含两种通配符，类似于正则表达式：“#”通配任何零个或多个word“*”通配任何单个word</p> <p><strong>4.常用命令</strong></p> <p>启动web管理工具:安装目录的sbin 目录下 rabbitmq-plugins.bat enable rabbitmq_management</p> <p>暂停服务：net stop RabbitMQ</p> <p>开启服务：net start RabbitMQ</p> <p>查看已有用户：rabbitmqctl.bat list_users</p> <p>新增一个用户：rabbitmqctl.bat add_user username password</p> <p>设置用户为超级管理员 ：rabbitmqctl.bat set_user_tags username administrator</p> <p>修改密码：rabbitmqctl change_password userName newPassword</p> <p>删除用户：rabbitmqctl.bat delete_user username</p> <p>权限设置</p> <p>按照官方文档，用户权限指的是用户对exchange，queue的操作权限，包括配置权限，读写权限。我们配置权限会影响到exchange、queue的声明和删除。</p> <p>我们配置权限会影响到exchange、queue的声明和删除。</p> <p>读写权限影响到从queue里取消息、向exchange发送消息以及queue和exchange的绑定(binding)操作。</p> <p>例如： 将queue绑定到某exchange上，需要具有queue的可写权限，以及exchange的可读权限；向exchange发送消息需要具有exchange的可写权限；从queue里取数据需要具有queue的可读权限</p> <p>权限相关命令为：</p> <p>(1) 设置用户权限</p> <p>rabbitmqctl set_permissions -p VHostPath User ConfP WriteP ReadP</p> <p>(2) 查看(指定hostpath)所有用户的权限信息</p> <p>rabbitmqctl list_permissions [-p VHostPath]</p> <p>(3) 查看指定用户的权限信息</p> <p>rabbitmqctl list_user_permissions User</p> <p>(4) 清除用户的权限信息</p> <p>rabbitmqctl clear_permissions [-p VHostPath] User</p> <p>(1) 超级管理员(administrator)</p> <p>可登陆管理控制台(启用management plugin的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p> <p>(2) 监控者(monitoring)</p> <p>可登陆管理控制台(启用management plugin的情况下)，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p> <p>(3) 策略制定者(policymaker)</p> <p>可登陆管理控制台(启用management plugin的情况下), 同时可以对policy进行管理。</p> <p>(4) 普通管理者(management)</p> <p>仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对策略进行管理。</p> <p>(5) 其他的</p> <p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p> <p>5.主要端口说明</p> <ul><li>4369 (epmd), 25672 (Erlang distribution)</li> <li>5672, 5671 (AMQP 0-9-1 without and with TLS)</li> <li>15672 (if management plugin is enabled)</li> <li>61613, 61614 (if STOMP is enabled)</li> <li>1883, 8883 (if MQTT is enabled)</li></ul> <p>**4369 (epmd), 25672 (Erlang distribution)**Epmd 是 Erlang Port Mapper Daemon 的缩写，在 Erlang 集群中相当于 dns 的作用，绑定在4369端口上。</p> <p>**5672, 5671 (AMQP 0-9-1 without and with TLS)**AMQP 是 Advanced Message Queuing Protocol 的缩写，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，专为面向消息的中间件设计。基于此协议的客户端与消息中间件之间可以传递消息，并不受客户端/中间件不同产品、不同的开发语言等条件的限制。Erlang 中的实现有 RabbitMQ 等。</p> <p>**15672 (if management plugin is enabled)**通过 http://serverip:15672 访问 RabbitMQ 的 Web 管理界面，默认用户名密码都是 guest。（注意：RabbitMQ 3.0之前的版本默认端口是55672，下同）</p> <p>**61613, 61614 (if STOMP is enabled)**Stomp 是一个简单的消息文本协议，它的设计核心理念就是简单与可用性，官方文档，实践一下 Stomp 协议需要：</p> <p>一个支持 stomp 消息协议的 messaging server (譬如activemq，rabbitmq）；一个终端（譬如linux shell);一些基本命令与操作（譬如nc，telnet)</p> <p>**1883, 8883 (if MQTT is enabled)**MQTT 只是 IBM 推出的一个消息协议，基于 TCP/IP 的。两个 App 端发送和接收消息需要中间人，这个中间人就是消息服务器（比如ActiveMQ/RabbitMQ），三者通信协议就是 MQTT</p> <p>6.参考文档：</p> <p>https://www.cnblogs.com/frankyou/p/5283539.html</p> <p>https://www.cnblogs.com/diegodu/p/4971586.html</p> <p>https://www.cnblogs.com/liuxingke/articles/9889517.html</p>]]></content:encoded>
        </item>
    </channel>
</rss>